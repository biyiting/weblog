---
title: 分治
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
abbrlink: 99c0330a
date: 2022-07-11 11:24:49
---

## 分治基础
1. 分治法：
    - 把复杂的问题分成两个或更多的相同或相似的子问题，直到子问题可直接求解，原问题的解即子问题的解的合并；
    - 在计算机科学中，分治法是种很重要的算法范式； 
    - 是很多高效算法的基础，如快速排序算法、快速傅立叶变换等；
2. 分治法解题的一般步骤：
    - 分解：将要解决的问题划分成若干规模较小的同类问题； 
    - 求解：递归地求解各个子问题，当子问题划分得足够小时，用较简单的方法解决； 
    - 合并：按原问题的要求，将子问题的解逐层合并构成原问题的解；

## [排序链表](https://leetcode.cn/problems/sort-list/)
1. 解题思路：
    - 找到链表的中点，以中点为分界，将链表拆分成两个子链表；（876. 链表的中间结点）
    - 对两个子链表分别排序；
    - 将两个排序后的子链表合并，得到完整的排序后的链表；（21. 合并两个有序链表）
2. 图解：
    <img src="排序链表.jpg" width="600px" height="auto" class="lazy-load" title="排序链表"/>
3. 复杂度：
    - 时间复杂度：O(nlogn)，其中 n 是链表的长度；
    - 空间复杂度：O(logn)，其中 n 是链表的长度，空间复杂度主要取决于递归调用的栈空间；
4. 代码实现：
    ```TS
    function sortList(head: ListNode | null): ListNode | null {
      // 终止条件
      if (head == null || head.next == null) {
        return head;
      }

      // 获取链表中间节点
      let midNode = getMiddleNode(head);
      let rightHead = midNode.next;
      // 断开链表
      midNode.next = null;

      let left = sortList(head);
      let right = sortList(rightHead);
      // 合并有序链表
      return mergeTwoLists(left, right);
    }
    // 利用快慢指针找到中间节点
    var getMiddleNode = function (head: ListNode | null): ListNode | null {
      if (head == null || head.next == null) {
        return head;
      }

      let slow = head;
      let fast = head.next.next;

      while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
      }

      return slow;
    };

    // 合并两个有序链表
    var mergeTwoLists = function (l1: ListNode | null, l2: ListNode | null): ListNode | null {
      let dmy = { next: null };
      let curr = dmy;

      while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
          curr.next = l1;
          l1 = l1.next;
        } else {
          curr.next = l2;
          l2 = l2.next;
        }
        curr = curr.next;
      }
      curr.next = l1 != null ? l1 : l2;

      return dmy.next;
    };
    ```


## [排序矩阵查找](https://leetcode.cn/problems/sorted-matrix-search-lcci/)
### 分治
1. 解题思路：
    <img src="排序矩阵查找（分治）.jpg" width="600px" height="auto" class="lazy-load" title="排序矩阵查找（分治）"/>

    - 使用分治法，先比较目标与矩阵对角线元素，找到元素返回 true，找不到则分解；
    - 步骤一 分解：矩阵被划分成 4个 子问题：可以看到绿色部分一定小于目标元素；红色部分一定大于目标元素；只需在剩下的两个行列升序的矩阵中寻找目标元素；
    - 步骤二 子问题分别求解：子问题元素个数为 0 或者最小元素大于目标返回 false；否则对两个子矩阵继续递归分解；
    - 步骤三 合并： 任一子矩阵内寻找到目标元素，则返回 true；
2. 复杂度：
    - 时间复杂度：O((m+n)*log(m+n))；从矩阵左上方开始不断比较目标值与对角线元素，寻找划分位置；如果未找到目标值，接着继续在两个子矩阵重复这个过程（递归）；
    - 空间复杂度：O(log(m+n))；需常数级临时变量；递归调用占用额外空间，递归深度为log(m+n)；
3. 代码实现：
    ```JS
    var searchMatrix = function (matrix, target) {
      let row = matrix.length;
      if (row === 0) return false;

      let col = matrix[0].length;
      if (col === 0) return false;

      return searchSubMatrix(matrix, target, 0, 0, row - 1, col - 1);
    };

    function searchSubMatrix(matrix, target, startRow, startColumn, endRow, endColumn) {
      // 1.结束条件：
      //    元素个数小于1
      //    矩阵最小元素大于目标值（所有元素都大于目标值）
      if (startRow > endRow || startColumn > endColumn || matrix[startRow][startColumn] > target) return false;

      // 对角线元素个数
      let diagonalLen = Math.min(endRow - startRow + 1, endColumn - startColumn + 1);
      // 在对角线上查找元素、分解问题、递归求解、合并
      for (let i = 0; i < diagonalLen; i++) {
        if (matrix[startRow + i][startColumn + i] === target) return true;
        // 当找到对角线最后 或者 下一个对角线的值大于 target
        if (i === diagonalLen - 1 || matrix[startRow + i + 1][startColumn + i + 1] > target) {
          // 找到了分界点，寻找 4 个区域中的剩下两个（右上、左下）
          return searchSubMatrix(matrix, target, startRow, startColumn + i + 1, startRow + i, endColumn)
              || searchSubMatrix(matrix, target, startRow + i + 1, startColumn, endRow, startColumn + i);
        }
      }

      return false;
    }
    ```

### 双指针
1. 解题思路：
    <img src="排序矩阵查找（双指针）.jpg" width="600px" height="auto" class="lazy-load" title="排序矩阵查找（双指针）"/>

    - 从矩阵右上方元素开始，比较当前元素与目标值的大小；
    - 若当前元素等于目标值，那么返回 true； 
    - 若当前元素小于目标值，那么当前元素左侧的元素都会小于目标值，指针下移；
    - 若当前元素大于目标值，那么当前元素右下方的元素都会大于目标值，指针左移；
    - 若指针在矩阵外，返回 false；
2. 复杂度：
    - 时间复杂度：O(m+n)，最多比较 m+n-1 次； 
    - 空间复杂度：O(1)，空间消耗方面只需常数级临时变量；
3. 代码实现：
    ```JS
    var searchMatrix = function (matrix, target) {
      let row = matrix.length;
      if (row === 0) return false;

      let col = matrix[0].length;
      if (col === 0) return false;

      // 初始位置为右上角的元素
      let currentRow = 0, currentColumn = col - 1;
      while (currentColumn >= 0 && currentRow < row) {
        // 当前元素等于target
        if (matrix[currentRow][currentColumn] === target) return true;
        if (matrix[currentRow][currentColumn] < target) {
          // 当前元素小于target，指针下移
          currentRow++;
        } else {
          // 当前元素大于target，指针左移
          currentColumn--;
        }
      }

      return false;
    };
    ```

## [多数元素](https://leetcode.cn/problems/majority-element/)
### 排序
1. 解题思路：
    - 排序数组，如果有一个数字出现的频率大于 n/2，则在数组 nums.length / 2 的位置就是这个数；
2. 复杂度：
    - 时间复杂度：O(nlogn)，快排的时间复杂度；
    - 空间复杂度：O(logn)，排序需要 logn 的空间复杂度；
3. 代码实现：
    ```JS
    var majorityElement = function (nums) {
      nums.sort((a, b) => a - b);
      return nums[Math.floor(nums.length / 2)];
    };
    ```

### 哈希
1. 解题思路：
    - 循环数组，用哈希表存储数字和对应的个数，如果数字出现的个数大于 n/2 则返回这个数；
2. 复杂度：
    - 时间复杂度：O(n)，n 为 nums 数组的长度；
    - 空间复杂度：O(n），哈希表需要的空间；
3. 代码实现：
    ```JS
    var majorityElement = function (nums) {
      let half = nums.length / 2;
      let map = new Map;

      for (let num of nums) {
        if (map.has(num)) {
          let currNum = map.get(num);
          map.set(num, currNum + 1);
        } else {
          map.set(num, 1);
        }

        if (map.get(num) > half) return num;
      }
    };
    ```

### 摩尔投票法
1. 解题思路：
    - 维护一个候选众数 candidate 和它出现的次数 count，初始时 candidate 可以为任意值，count 为 0；
    - 遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，先将 x 的值赋予 candidate，随后判断 x：
      - 如果 x 与 candidate 相等，那么计数器 count 的值增加 1；
      - 如果 x 与 candidate 不等，那么计数器 count 的值减少 1，当减少为 0 时，将下一个数赋予 candidate；
    - 在遍历完成后，candidate 即为整个数组的众数；
2. 复杂度：
    - 时间复杂度：O(n)，只对数组进行了一次遍历；
    - 空间复杂度：O(1)，只需要常数级别的额外空间；
3. 代码实现：
    ```JS
    const majorityElement = nums => {
      let count = 1;
      // 将第一个数赋予 majority
      let majority = nums[0];

      for (let i = 1; i < nums.length; i++) {
        if (count === 0) {
          majority = nums[i];
        }

        if (nums[i] === majority) {
          count++;
        } else {
          count--;
        }
      }

      return majority;
    };
    ```

### 分治
1. 解题思路：
    - 使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组；
    - 长度为 1 的子数组中唯一的数显然是众数，直接返回即可；如果回溯后某区间的长度大于 1，必须将左右子区间的值合并；如果它们的众数相同，那么显然这一段区间的众数是它们相同的值；否则，需要比较两个众数在整个区间内出现的次数来决定该区间的众数；
2. 复杂度：
    - 时间复杂度：O(nlogn)；
    - 空间复杂度：O(logn)；尽管分治算法没有直接分配额外的数组空间，但在递归的过程中使用了额外的栈空间；算法每次将数组从中间分成两部分，所以数组长度变为 1 之前需要进行O(logn) 次递归，即空间复杂度为 O(logn)；
3. 代码实现：
    ```JS
    var majorityElement = function (nums) {
      const getMode = (low, high) => {
        if (low === high) return nums[low];

        //拆分成更小的区间，一分为二
        let mid = Math.floor((low + high) / 2);

        let left = getMode(low, mid);
        let right = getMode(mid + 1, high);

        if (left === right) return left;

        let leftCount = getCount(left, low, high);// 统计区间内 left 的个数
        let rightCount = getCount(right, low, high);// 统计区间内 right 的个数

        return leftCount > rightCount ? left : right;// 返回 left 和 right 中个数多的那个
      };

      //统计 low 到 high 之间 num 的数量
      var getCount = (num, low, high) => {
        let count = 0;
        for (let i = low; i <= high; i++) {
          if (nums[i] === num) count++;
        }
        return count;
      };

      return getMode(0, nums.length - 1);
    };
    ```
---
title: 单调栈
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 单调栈
abbrlink: 16518a5d
date: 2022-07-07 11:24:49
---
## [最小栈](https://leetcode.cn/problems/min-stack/)
1. 解题思路：
    - 借用一个辅助栈 min_stack，用于存获取 stack 中最小值；
    - 算法流程：
      - push()方法： 每当 push() 新值进来时，如果小于等于 min_stack 栈顶值，则一起 push() 到 min_stack，即更新了栈顶最小值，如果大于栈顶值则将栈顶值 push 进 min_stack 占位；
      - pop()方法： stack 和 min_stack 一起 pop()；
      - getMin()方法： 返回 min_stack 栈顶即可；
    - min_stack作用分析：
      - min_stack 等价于遍历 stack 所有元素，把升序的数字都删除掉，留下一个从栈底到栈顶非严格降序的栈；
      - 相当于给 stack 中的降序元素做了标记，每当 pop() 这些降序元素，min_stack 会将相应的栈顶元素 pop()出去，保证其栈顶元素始终是 stack 中的最小元素；
2. 图解：
    <img src="最小栈1.jpg" width="600px" height="auto" class="lazy-load" title="最小栈"/>
    <img src="最小栈2.jpg" width="600px" height="auto" class="lazy-load" title="最小栈"/>
    <img src="最小栈3.jpg" width="600px" height="auto" class="lazy-load" title="最小栈"/>
    <img src="最小栈4.jpg" width="600px" height="auto" class="lazy-load" title="最小栈"/>
    <img src="最小栈5.jpg" width="600px" height="auto" class="lazy-load" title="最小栈"/>
3. 复杂度：
    - 时间复杂度： O(1)，压栈，出栈，获取最小值的时间复杂度都为 O(1)；
    - 空间复杂度： O(N)，包含 N 个元素辅助栈占用线性大小的额外空间；
4. 代码实现：
    ```JS
    var MinStack = function () {
      this.stack = [];
      this.min_stack = [Infinity];
    };

    // stack正常push，min_stack只会push需要入栈和栈顶中较小的元素
    MinStack.prototype.push = function (x) {
      this.stack.push(x);
      this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));
    };

    // stack正常pop，min_stack正常pop
    MinStack.prototype.pop = function () {
      this.stack.pop();
      this.min_stack.pop();
    };

    // 返回stack栈顶元素
    MinStack.prototype.top = function () {
      return this.stack[this.stack.length - 1];
    };

    // 返回min_stack栈顶元素
    MinStack.prototype.getMin = function () {
      return this.min_stack[this.min_stack.length - 1];
    };
    ```


## [每日温度](https://leetcode.cn/problems/daily-temperatures/)
1. 解题思路：
    - 遍历每日温度，维护一个单调栈；
      - 若栈为空 或者 当日温度小于等于栈顶温度，则直接入栈；
      - 若栈不为空，当日温度大于栈顶元素，说明栈顶元素的升温日找到了，出栈并计算天数，继续判断栈顶元素；
    - 因为求的是天数，所以栈中存储的是索引下标；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是温度列表的长度，正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作；
    - 空间复杂度：O(n)，其中 n 是温度列表的长度，需要维护一个单调栈存储温度列表中的下标；
3. 代码实现：
    ```TS
    function dailyTemperatures(temperatures: number[]): number[] {
      let n = temperatures.length;
      let res = new Array(n).fill(0);

      // 单调栈
      let stack = [0]

      // 遍历每日温度，维护一个单调栈
      for (let i = 1; i < n; i++) {
        // 当日温度大于栈顶温度，说明栈顶温度的升温日找到了，栈顶出栈并计算天数；继续判断栈顶元素
        while (stack.length && temperatures[i] > temperatures[stack[stack.length - 1]]) {
          const top = stack.pop()
          res[top] = i - top
        }
        // 栈为空 或 每日温度小于等于栈顶温度 => 直接入栈
        stack.push(i)
      }

      return res;
    };
    ```


## [下一个更大元素Ⅰ](https://leetcode.cn/problems/next-greater-element-i/)
1. 解题思路：
    - 预处理 nums2 得到所有的存在下一个更大的元素；
      - 维护一个单调栈，并迭代 nums2；
      - 如果栈是空的或者当前元素大于栈顶元素，则出栈放入 map，栈顶元素作为 key，当前元素作为 value；
      - 继续迭代，继续和栈顶元素比较，是否存在下一个更大的元素；
      - 迭代完成后，栈中的数据代表不存在下一个更大的元素，则放入 map，元素作为 key，value 为 -1；Ï
    - 最后根据 num1 返回 num2 中的对应的下一个更大元素的数组；
2. 复杂度：
    - 时间复杂度：O(m + n)；
      - 其中 n 是 nums2 的长度，需要遍历 nums2 以计算 nums2 中每个元素右边的第一个更大的值；
      - 其中 m 是 nums1 的长度，需要遍历 nums1 以生成查询结果；
    - 空间复杂度：O(n)，用于存储哈希表；
3. 代码实现：
    ```TS
    function nextGreaterElement(nums1: number[], nums2: number[]): number[] {
      let map = new Map(), stack = [], ans = [];

      // 找到所有存在下一个更大的元素，放入map中，key：栈顶元素，value：当前元素
      nums2.forEach(item => {
        while (stack.length && item > stack[stack.length - 1]) {
          map.set(stack.pop(), item)
        };
        stack.push(item);
      });

      // 剩下来的元素就是没有找到最大值的
      stack.forEach(item => map.set(item, -1));

      // 遍历 nums1 将结果推入 ans 中
      nums1.forEach(item => ans.push(map.get(item)));

      return ans;

      // return nums1.map(it => map.get(it))
    };
    ```


## [下一个更大元素Ⅱ](https://leetcode.cn/problems/next-greater-element-ii/)
1. 解题思路：
    - 预处理 nums 得到所有的存在下一个更大的元素；
      - 维护一个单调栈，并迭代 nums；
      - 如果栈是空的或者当前元素大于栈顶元素，则说明当前元素是栈顶的「下一个更大的元素」，弹出栈顶，继续判断当前元素和栈顶元素；
      - 如果当前元素比栈顶元素小，则把当前元素入栈，继续寻找「下一个更大的元素」；
    - 结果数组默认全部填充 -1，栈中剩余的元素找不到「下一个更大的元素」，为 -1；
    - 由于是循环数组，使用取模运算 %可以把下标  i 映射到数组 nums 长度的  0 - N 内；
2. 复杂度：
    - 时间复杂度: O(n)，其中 n 是序列的长度，需要遍历该数组中每个元素最多 2 次，每个元素出栈与入栈的总次数也不超过 4 次；
    - 空间复杂度: O(n)，其中 n 是序列的长度，空间复杂度主要取决于栈的大小，栈的大小至多为 2n-1；
3. 代码实现：
    ```TS
    function nextGreaterElements(nums: number[]): number[] {
      const stack = []
      let len = nums.length
      // 结果数组默认全部填充 -1，栈中剩余的元素找不到「下一个更大的元素」，为 -1
      let res = new Array(len).fill(-1)

      for (let i = 0; i < len * 2; i++) {
        let num = nums[i % len]
        while (stack.length && num > nums[stack[stack.length - 1]]) {
          const index = stack.pop()
          res[index] = num
        }
        stack.push(i % len)
      }

      return res
    };
    ```

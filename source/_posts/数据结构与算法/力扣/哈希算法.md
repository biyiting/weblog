---
title: 哈希算法
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 哈希
abbrlink: d98ef1d2
date: 2022-06-22 11:24:49
---

## [两数之和](https://leetcode.cn/problems/two-sum/)
### 暴力解法
1. 复杂度
    >- 时间复杂度：O(N^2)，其中 N 是数组中的元素数量，最坏情况下数组中任意两个数都要被匹配一次；
    >- 空间复杂度：O(1)；
2. 代码实现
    ```JS
    var twoSum = function (nums, target) {
      for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < nums.length; j++) {
          if (target === (nums[i] + nums[j]) && i !== j) {
            return [i, j]
          }
        }
      }
    };
    ```
### 哈希：空间换时间
1. 解题思路
    >- 定一个 object，将遍历的目标值放入其中，例如 nums = [2，7，11，15]，target = 9；
    >- nums 第一项 2 的目标值为 7，直接将目标值放入 obj，即{ 7: 0 }；
    >- nums 第二项 7，存在 obj 的key中，则直接返回 [0,1];
2. 复杂度
    >- 时间复杂度：O(N)；
    >- 空间复杂度：O(N)；
3. 代码实现
    ```JS
    var twoSum = function (nums, target) {
      // { num : 索引 i}
      let obj = {}
      for (let i = 0; i < nums.length; i++) {
        let num = nums[i]
    
        // 获取目标数字
        let n = target - num
    
        // 当遍历到 num 在 obj 中，可直接返回结果
        if (num in obj) {
          return [i, obj[num]]
        } else {
          // 目标数字存储在 obj 中，{n：i}
          obj[n] = i
        }
      }
    }
    ```

## [两个数组的交集 Ⅱ](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)
### 哈希
1. 解题思路：
    >- 由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数，对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值；
    >- 首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数；
    >- 为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集；
2. 复杂度：
    >- 时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度，需要遍历两个数组并对哈希表进行操作，哈希表操作的时间复杂度是 O(1)，因此总时间复杂度与两个数组的长度和呈线性关系；
    >- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度，对较短的数组进行哈希表的操作，哈希表的大小不会超过较短的数组的长度，为返回值创建一个数组 intersection，其长度为较短的数组的长度；
3. 代码实现：
    ```JS
    var intersect = function (nums1, nums2) {
      let set = {};
      let res = [];
      
      for (let inx = 0; inx < nums1.length; inx++) {
        nums1[inx] in set ? set[nums1[inx]]++ : set[nums1[inx]] = 1;
      }
    
      for (let j = 0; j < nums2.length; j++) {
        if (nums2[j] in set && set[nums2[j]] > 0) {
          res.push(nums2[j]);
          set[nums2[j]]--;
        }
      }
    
      return res;
    };
    ```

### 排序+双数组双指针
1. 解题思路：
>- 如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集；
>- 首先对两个数组进行排序，然后使用两个指针遍历两个数组；
>   - 初始时，两个指针分别指向两个数组的头部；
>   - 每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位；
>   - 如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位；
>   - 当至少有一个指针超出数组范围时，遍历结束；
2. 复杂度：
>- 时间复杂度：O(mlogm+nlogn)，其中 m 和 n 分别是两个数组的长度，对两个数组进行排序的时间复杂度是 O(mlogm+nlogn)，遍历两个数组的时间复杂度是 O(m+n)，因此总时间复杂度是 O(mlogm+nlogn)；
>- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度；
3. 代码实现：
    ```js
    var intersect = function (nums1, nums2) {
      let inx1 = 0
      let inx2 = 0
      let res = []
    
      nums1.sort((a, b) => a - b)
      nums2.sort((a, b) => a - b)
    
      while (inx1 < nums1.length && inx2 < nums2.length) {
        if (nums1[inx1] === nums2[inx2]) {
          res.push(nums1[inx1])
          inx1++
          inx2++
        } else if (nums1[inx1] > nums2[inx2]) {
          inx2++
        } else {
          inx1++
        }
      }
    
      return res
    };
    ```

## [快乐数](https://leetcode.cn/problems/happy-number/)
### 哈希
1. 解题思路：
> - 根据题意可知：最终会得到 1；最终会进入循环；
> - 可以用 hash 的方式来判断是不是循环；
2. 代码实现：
    ```JS
    var isHappy = function (n) {
        let set = new Set();
    
        while (n !== 1) {
            n = getNext(n)
            if (set.has(n)) {
                return false;
            }
            set.add(n);
        }
    
        return n === 1;
    };
    
    var getNext = function (n) {
        let sum = 0;
        while (n > 0) {
            sum += Math.pow(n % 10, 2);
            n = Math.floor(n / 10);
        }
        return sum;
    }
    ```

### 快慢指针
1. 解题思路：
    > - 使用两个指针，fast 与 slow，它们起始都位于链表的头部；
    > - 随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置；
    > - 如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇；
    
    <img src="快慢指针.jpg" width="600px" height="auto" class="lazy-load" title="快慢指针"/>
2. 代码实现
    ```JS
    let isHappy = function (n) {
        let slow = n;
        // 有可能第一步就判断出是快乐数
        let fast = getNext(n);
    
        while (fast !== 1) {
            slow = getNext(slow);
            fast = getNext(getNext(fast));
            if (slow === fast) {
                return false;
            }
        }
    
        return fast === 1;
    }
    
    let getNext = function (n) {
        let sum = 0;
        while (n > 0) {
            sum += Math.pow(n % 10, 2);
            n = Math.floor(n / 10);
        }
        return sum;
    }
    ```

## [有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)
1. 解题思路：
    >- 字符串 s 的每一个字符存储在哈希表中，并计数 +1；
    >- 字符串 t 的字符在哈希表中出现一次，则计数 -1；
    >- 最后遍历哈希表：若还有不为 0 的值，则不是有效的字母异位词；若没有不为 0 的值，则是有效的字母异位词；
2. 复杂度：
    >- 时间复杂度：O(n)，其中 n 为 s 的长度；
    >- 空间复杂度：O(n)，其中 n 为 s 的长度；
3. 代码实现：
    ```JS
    var isAnagram = function (s, t) {
        if (s.length !== t.length) return false;
    
        let hash = {};
    
        for (let i = 0; i < s.length; i++) {
            const el = s[i];
            el in hash ? hash[el]++ : hash[el] = 1;
        }
        for (let i = 0; i < t.length; i++) {
            const el = t[i];
            if (el in hash) {
                hash[el]--;
            } else {
                return false;
            }
        }
    
        for (let key in hash) {
            if (hash[key] !== 0) {
                return false;
            }
        }
        return true;
    };
    ```

## [赎金信](https://leetcode.cn/problems/ransom-note/)
1. 解题思路：
    >- 字符串 magazine 的每一个字符存储在哈希表中，并计数 +1；
    >- 字符串 ransomNote 的字符在哈希表中出现一次，则计数 -1；
    >- 最后遍历哈希表，若有值小于 0 返回 false，否则返回true
2. 复杂度：
    >- 时间复杂度：O(n)，其中 n 为 s 的长度；
    >- 空间复杂度：O(n)，其中 n 为 s 的长度；
3. 代码实现：
    ```JS
    var canConstruct = function (ransomNote, magazine) {
        if (magazine.length < ransomNote.length) return false;
    
        let hash = {};
    
        // 将 magazine 中的所有字符和出现的次数放到 hash中
        for (let i = 0; i < magazine.length; i++) {
            let r = magazine[i];
            r in hash ? hash[r]++ : hash[r] = 1;
        }
        // 遍历 ransomNote ，取出 hash 中的字符串
        for (let i = 0; i < ransomNote.length; i++) {
            let m = ransomNote[i];
            if (m in hash && hash[m] - 1 >= 0) {
                hash[m]--;
            } else {
                return false;
            }
        }
    
        return true;
    };
    ```

## [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
1. 解题思路：
>- 定义变量 maxLen 表示最大长度，定义一个 map 用来存储出现过的字符和该字符的索引；
>- 使用双指针 left、right 截取不含重复字符的子串；
>   - left 和 right 初始值都是 0，right 不断右移，不断将 right 位置的字符放到 map 中；
>   - 如果存在重复字母，left 直接移动到重复字母的索引位置+1（只取索引大于 left 的重复字母的索引）；
>   -  如果不存在重复字母，right 不断右移；
>- 计算子串长度 right - left + 1，保留较大值到 maxLen；
2. 复杂度：
>- 时间复杂度：O(n)；
>- 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function lengthOfLongestSubstring(s: string): number {
      let map: Map<string, number> = new Map();
      let left: number = 0, right: number = 0, maxLen: number = 0;

      while (right < s.length) {
          let letter = s[right];
          if (map.has(letter)) {
              let inx = map.get(letter) + 1;
              left = left > inx ? left : inx;
          }

          map.set(letter, right);
          maxLen = Math.max(maxLen, right - left + 1);
          right++;
      }

      return maxLen;
    };
    ```
    ```JS
    var lengthOfLongestSubstring = function (s) {
        let map = new Map();
        let left = 0, right = 0, maxLen = 0;

        while (right < s.length) {
            let letter = s[right];
            if (map.has(letter)) {
                let inx = map.get(letter) + 1;
                left = left > inx ? left : inx;
            }

            map.set(letter, right);
            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }

        return maxLen;
    };
    ```

## [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)
1. 解题思路：
>- 用哈希表的方法来做，用 map 来存储字母相同的单词；
>- 将每一个单词的字母排序后用作 key, 保证相同字母的单词的 key相同，遍历一次数组即可将所有字母相同的单词放在同一 key 中；
2. 图解：
    <img src="字母异位词分组.jpg" width="600px" height="auto" class="lazy-load" title="字母异位词分组"/>
3. 复杂度：
>- 时间复杂度：O(nklogk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度；需要遍历 n 个字符串，对于每个字符串，需要 O(klogk) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nklogk)；
>- 空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度，需要用哈希表存储全部字符串；
4. 代码实现：
    ```TS
    function groupAnagrams(strs: string[]): string[][] {
      let map: Map<string, Array<string>> = new Map();

      for (let i = 0; i < strs.length; i++) {
        // 将字母排序后用作 map key，如 'eve' => 'eev'， 'vee' => 'eev'
        let key = strs[i].split("").sort().join("");

        if (!map.has(key)) {
          map.set(key, []);
        }
        map.get(key).push(strs[i]);
      }

      return [...map.values()];
    }
    ```
    ```JS
    var groupAnagrams = function (strs) {
        let map = new Map();

        for (let i = 0; i < strs.length; i++) {
            // 将字母排序后用作 map key，如 'eve' => 'eev'， 'vee' => 'eev'
            let key = strs[i].split('').sort().join('');

            if (!map.has(key)) {
                map.set(key, []);
            }
            map.get(key).push(strs[i]);
        }

        return [...map.values()];
    };
    ```

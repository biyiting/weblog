---
title: 链表
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 链表
abbrlink: 2362a8ea
date: 2022-06-16 11:24:49
---

## 链表
### 链表基础
1. 为什么不直接使用数组：
    - 数组在内存中占用一段连续的空间；
    - 添加、移除会导致后续元素位移，性能开销大，时间复杂度为 0(n)；
      ```JS
      const arr = []
      console.time('perfTest')
      for (let i = 0; i < 100000; i++) {
        // arr.push(i)
        arr.unshift(i)
      }
      console.timeEnd('perfTest')
      ```
2. 概念：
    - 链表是有序的数据结构，链表中的每个部分称为节点；
    - 链表可以从首、尾、中间进行数据存取；
    - 链表的元素在内存中不必是连续的空间；
    - 优点：添加与删除不会导致其余元素位移；
    - 缺点：无法根据索引快速定位元素；
3. 单链表的存储结构：
    <img src="单链表的存储结构.jpg" width="600px" height="auto" class="lazy-load" title="单链表的存储结构"/>
4. 时间复杂度：
    - prepend：O(1)；
    - append：O(1)；
    - lookup：O(n)；
    - insert：O(1)；
    - delete：O(1)；
5. 小结：
    - 获取、修改元素时，数组效率高；
    - 添加、删除元素时，链表效率高；

### 如何给链表加速
1. 跳表（升维、空间换时间）
    - 跳表，又叫做跳跃表、跳跃列表，在有序链表的基础上增加了“跳跃”的功能；
    - 跳表在原来的有序链表上加上了多级索引，通过索引来快速查找；可以支持快速的删除、插入和查找操作；
    - 跳表实际上是一种增加了前向指针的链表，是一种随机化的数据结构；
2. 跳表的数据结构图型：
    - 如何提高链表的线性查找的效率？
      <img src="如何提高链表的线性查找的效率.jpg" width="600px" height="auto" class="lazy-load" title="如何提高链表的线性查找的效率？"/>
    - 如何进一步提高链表的线性查找的效率？
      <img src="如何进一步提高链表的线性查找的效率.jpg" width="600px" height="auto" class="lazy-load" title="如何进一步提高链表的线性查找的效率？"/>
    - 增加多级索引：索引级数为 log2n ；
      <img src="增加多级索引.jpg" width="600px" height="auto" class="lazy-load" title="增加多级索引"/>
3. 跳表查询的时间复杂度：O(logn)
    - 索引个数：n/2、n/4、n/8、...第 k 级索引节点个数为 n/(2k);
    - 假设索引有 h 级，最高级索引有 2 个节点，即 n/2h = 2，h = log2n - 1；
    - 则时间复杂度为 O(logn)；
4. 跳表查询的空间复杂度：O(n)
    - 原始链表大小为 n，每 2 个节点抽一个，每层节点数：n/2、n/4、......8、4、2；
    - 原始链表大小为 n，每 3 个节点抽一个，每层节点数：n/3、n/9、......9、3、1；
    - 则空间复杂度为 O(n);
5. 现实中跳表的形态：
    <img src="现实中跳表的形态.jpg" width="600px" height="auto" class="lazy-load" title="现实中跳表的形态"/>

    - 由于跳表的增删操作，索引不是那么连续规律的；
    - 维护成本较高，增加删除要更新一遍索引；

### 单链表的实现
1. 实现以下功能：
    - 节点类：value、next
    - 链表类：
      - addAtTail()： 尾部添加节点；
      - addAtHead()： 头部添加节点；
      - addAtIndex()： 指定位置添加节点；
      - get()：获取节点；
      - removeAtIndex()： 删除指定节点；
2. 示例代码：
    ```JS
    // 节点类
    class LinkedNode {
      constructor(value) {
        this.value = value
        // 用于存储下一个节点的引用
        this.next = null
      }
    }

    // 链表类
    class LinkedList {
      constructor() {
        this.count = 0 // 单链表的长度
        this.head = null
      }

      // 添加节点 (尾）
      addAtTail(value) {
        // 创建新节点
        const node = new LinkedNode(value)
        // 检测链表是否存在数据
        if (this.count === 0) {
          this.head = node
        } else {
          // 找到链表尾部节点，将最后一个节点的 next 设置为 node
          let cur = this.head
          while (cur.next != null) {
            cur = cur.next
          }
          cur.next = node
        }
        this.count++
      }

      // 添加节点（首）
      addAtHead(value) {
        const node = new LinkedNode(value)
        if (this.count === 0) {
          this.head = node
        } else {
          // 将 node 添加到 head 的前面
          node.next = this.head
          this.head = node
        }
        this.count++
      }

      // 获取节点（根据索引）
      get(index) {
        if (this.count === 0 || index < 0 || index >= this.count) {
          return
        }
        // 迭代链表，找到对应节点
        let current = this.head
        for (let i = 0; i < index; i++) {
          current = current.next
        }
        return current
      }

      // 添加节点（根据索引）
      addAtIndex(value, index) {
        if (this.count === 0 || index >= this.count) {
          return
        }
        // 如果 index <= 0，都添加到头部即可
        if (index <= 0) {
          return this.addAtHead(value)
        }
        // 后面为正常区间处理
        const prev = this.get(index - 1)
        const next = prev.next
        const node = new LinkedNode(value)
        prev.next = node
        node.next = next
        this.count++
      }

      // 删除（根据索引）
      removeAtIndex(index) {
        if (this.count === 0 || index < 0 || index >= this.count) {
          return
        }
        if (index === 0) {
          this.head = this.head.next
        } else {
          const prev = this.get(index - 1)
          prev.next = prev.next.next
        }
        this.count--
      }
    }

    // 测试代码
    const l = new LinkedList()
    l.addAtTail('a')
    l.addAtTail('b')
    l.addAtTail('c')
    ```

### 常见的链表形式
1. 双向链表（双端链表）：
    - 双向链表指的是在普通链表的基础上，增加一个用于记录上一个节点的属性 prev，可进行双向访问；
    - 图示：
      <img src="双向链表.jpg" width="600px" height="auto" class="lazy-load" title="双向链表"/>
2. 循环链表（环形链表）：
    - 链表的最后一个节点的 next 指向第一个节点，形成首尾相连的循环结构，称为循环链表；
    - 在实际中，环的结束可以为链表的任意节点；
    - 图示：
      <img src="循环链表.jpg" width="600px" height="auto" class="lazy-load" title="循环链表"/>




## 递归
### [反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
#### 递归
1. 图解：
    <img src="反转链表1.jpg" width="600px" height="auto" class="lazy-load" title="反转链表"/>
    <img src="反转链表2.jpg" width="600px" height="auto" class="lazy-load" title="反转链表"/>
2. 复杂度：
    - 时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)；
    - 空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层；
3. 代码实现：
    ```TS
    function reverseList(head: ListNode | null): ListNode | null {
      // 递归终止条件
      if (head === null || head.next === null) return head;

      // 递归到最后一个节点，再从后向前进行反转（执行下面的代码）
      const prev = reverseList(head.next)

      // 反转
      head.next.next = head;
      // 断开原有指向，链表的最后节点指向 null
      head.next = null;

      // 并返回反转之后的头结点
      return prev;
    };
    ```

#### 迭代
1. 解题思路：
    - 在遍历链表时，将当前节点的 next 指针改为指向前一个节点；
    - 由于节点没有引用其前一个节点，因此必须事先存储其前一个节点；
    - 在更改引用之前，还需要存储后一个节点；
    - 最后返回新的头引用；
2. 图解：
    <img src="反转链表-迭代.jpg" width="600px" height="auto" class="lazy-load" title="反转链表"/>
3. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的长度，需要遍历链表一次；
    - 空间复杂度：O(1)；
4. 代码实现：
    ```TS
    function reverseList(head: ListNode | null): ListNode | null {
      // 记录上一个节点
      let prev = null
      // 记录当前节点
      let cur = head

      // 当 cur 是节点时，进行迭代
      while (cur) {
        // 先保存当前节点的下一个节点
        const next = cur.next
        // 反转链表
        cur.next = prev
        //  向下移动链表
        prev = cur
        // 取出存储的节点，继续循环
        cur = next
      }

      return prev
    };
    ```

#### 同类型
1. [反转链表](https://leetcode.cn/problems/UHnkqh/description/)
2. [反转链表](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/)


### [反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)
1. 解题思路：递归+反转区间链表+反转链表前 n 个节点
    - 此题是反转 [left，right] 区间内的链表；
    - reverseN 反转链表前 n 个节点；
      <img src="反转链表II.jpg" width="600px" height="auto" class="lazy-load" title="反转链表II"/>
    - reverseBetween 一直递归，直到 --left 为 1 的时候，说明此时可以直接 reverseN 反转链表前 n 个节点；
2. 复杂度：
    - 时间复杂度：O(N)；
    - 空间复杂度：O(N)；
3. 代码实现：
    ```TS
    let successor: ListNode = null; // 后驱节点

    // 反转链表的前 n 个节点
    function reverseN(head: ListNode, n: number): ListNode {
      // n ===1 说明当前 head 节点是第 n 个节点
      if (n === 1) {
        // 记录 n 的下一个节点
        successor = head.next;
        return head;
      }
      // 递归到 n 个节点，再从后向前进行反转（执行下面的代码）
      let last = reverseN(head.next, --n);
      head.next.next = head;
      // 反转前 n 个节点后的链表，与 n 后的链表连接在一起
      head.next = successor;
      return last;
    }

    // 反转 [m, n] 区间的链表（链表索引从 1 开始）
    function reverseBetween(head: ListNode | null, m: number, n: number): ListNode | null {
      // base case：反转前 n 个节点
      if (m === 1) return reverseN(head, n);

      // 前进到反转的起点，m===1 触发 base case
      head.next = reverseBetween(head.next, --m, --n);

      return head;
    };
    ```

### [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
#### 递归
1. 解题思路：
    - 第一步：定义两个指针 head、next 分别指向第一个和第二个节点；
    - 第二步：head 指针指向下下个节点；
    - 第三步：next 指针指向 head 节点，反转；
2. 图解：
    <img src="两两交换链表中的节点-递归.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-递归"/>
3. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的节点数量，需要对每个节点进行更新指针的操作；
    - 空间复杂度：O(n)，其中 n 是链表的节点数量，空间复杂度主要取决于递归调用的栈空间；
4. 代码实现：
    ```TS
    function swapPairs(head: ListNode | null): ListNode | null {
      if (head === null || head.next === null) return head;

      let next = head.next;
      head.next = swapPairs(head.next.next);
      next.next = head;

      // 返回反转后的头节点
      return next;
    };
    ```

#### 递归+stack
1. 解题思路：
    - 利用一个 stack，然后不断迭代链表，每次取出两个节点放入 stack 中，再从 stack 中拿出两个节点；
    - 借助 stack 后进先出的特点，放进去的时候是 1、2 ，拿出来的时候就是 2、1 两个节点了；
    - 再把这两个节点串联起来，重复这个逻辑遍历完整个链表，就可以做到两两反转的效果了；
2. 图解：
    <img src="两两交换链表中的节点-递归stack.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-递归stack"/>
3. 复杂度：
    - 空间复杂度还是 O(1)：虽然用到了 stack，但因为只存了两个元素，所以空间复杂度还是 O(1)；
    - 时间复杂度是 O(n)；
4. 代码实现：
    ```TS
    function swapPairs(head: ListNode | null): ListNode | null {
      if (head === null || head.next === null) return head;
      let stack = [];

      // 将 node1、node2 入栈
      stack.push(head);
      stack.push(head.next);

      // 出栈顺序为 node2、node1
      let node2 = stack.pop();
      let node1 = stack.pop();

      // node2 和 node1 反转
      node1.next = swapPairs(node2.next);
      node2.next = node1;

      return node2;
    };
    ```

#### 迭代
1. 解题思路：
    - 创建哑结点 dummyHead，令 dummyHead.next = head，temp 表示当前到达的节点，初始时 temp = dummyHead，每次需要交换 temp 后面的两个节点；
    - 如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换；
    - 否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点；
2. 图解：
    <img src="两两交换链表中的节点-迭代1.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
    <img src="两两交换链表中的节点-迭代2.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
    <img src="两两交换链表中的节点-迭代3.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
    <img src="两两交换链表中的节点-迭代4.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
    <img src="两两交换链表中的节点-迭代5.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
3. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的节点数量，需要对每个节点进行更新指针的操作；
    - 空间复杂度：O(1)；
4. 代码实现
    ```TS
    function swapPairs(head: ListNode | null): ListNode | null {
      const dmy = new ListNode(0, head);
      // 定义 curr 当前指针
      let curr = dmy;

      while (curr.next !== null && curr.next.next !== null) {
        // 定义 node1 和 node2 指针
        let node1 = curr.next;
        let node2 = curr.next.next;

        // 反转 node1 node2 指向
        curr.next = node2;
        node1.next = node2.next;
        node2.next = node1;

        // 移动 curr 指针
        curr = curr.next.next
      }

      return dmy.next;
    };
    ```


### [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)
#### 递归+拆分
1. 图解：
    <img src="K 个一组翻转链表.jpg" width="600px" height="auto" class="lazy-load" title="K 个一组翻转链表"/>
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 为链表的长度，head 指针会在 O(k/n) 个节点上停留，每次停留需要进行一次 O(k) 的翻转操作；
    - 空间复杂度：O(1)，只需要建立常数个变量；
3. 代码实现：
    ```TS
    function reverseKGroup(head: ListNode | null, k: number): ListNode | null {
      if (head === null || k === 1) return head;

      let start = head;
      let end = head;
      // 不足 k 个，不需要反转，base case
      for (let i = 0; i < k; i++) {
        if (end == null) return head;
        end = end.next;
      }

      // 反转区间 [start, end) 的链表，并返回反转后的头节点
      let newHead = reverse(start, end);

      // 递归反转后续链表并连接起来
      start.next = reverseKGroup(end, k);

      return newHead;
    };

    // 反转链表的前 n 个节点，[start, end)
    function reverse(start: ListNode, end: ListNode): ListNode {
      let prev = null;
      let curr = start;

      // 基于反转整个链表，while 终止的条件改成 curr ！== end
      while (curr !== end) {
        let next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
      }

      // 返回反转后的头结点
      return prev;
    }
    ```

#### 递归+栈
1. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的节点数量，需要对每个节点进行更新指针的操作；
    - 空间复杂度：O(n)，其中 n 是链表的节点数量；
2. 实现代码：
    ```TS
    function reverseKGroup(head: ListNode | null, k: number): ListNode | null {
      if (k === 1 || head === null || head.next === null) return head;

      // k 大于链表长度，直接返回 head
      let curr = head;
      for (let i = 0; i < k - 1; i++) {
        curr = curr.next;
        if (curr === null) return head;
      }

      // 将 k 个节点 依次入栈，node1、node2、node3...，nodek
      let stack = [];
      curr = head;
      for (let i = 0; i < k; i++) {
        stack.push(curr)
        curr = curr.next;
      }

      let first = stack[0];
      let last = stack[stack.length - 1];
      // 开始下一轮反转
      first.next = reverseKGroup(last.next, k);

      // 将 k 个节点 依次出栈，nodek、...，node2，node1
      curr = stack.pop();
      while (stack.length) {
        curr.next = stack.pop();
        curr = curr.next;
      }

      return last;
    };
    ```


## 合并
### [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)
#### 迭代+虚拟头结点
1. 解题思路：
    - 定义一个哨兵节点 dummy，使用 dummy->next 来保存需要返回的头节点；
    - 判断 l1 和 l2 哪个更小，就把这个节点接到 dummy 下一个；
    - 直到有一边为 null ，即可将另一边剩余的都接到 dummy 上；
2. 复杂度：
    - 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度；因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和；所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)；
    - 空间复杂度：O(1)，只需要常数的空间存放若干变量；
3. 代码实现：
    ```TS
    function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
      let dmy = new ListNode();
      let curr = dmy;

      while (list1 !== null && list2 !== null) {
        if (list1.val < list2.val) {
          curr.next = list1;
          list1 = list1.next;
        } else {
          curr.next = list2;
          list2 = list2.next;
      }
        curr = curr.next;
      }

      if (list1 === null) curr.next = list2;
      if (list2 === null) curr.next = list1;

      return dmy.next;
    };
    ```

#### 递归
1. 解题思路：
    - 终止条件：当两个链表都为空时，表示我们对链表已合并完成；
    - 如何递归：判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果；（调用递归）
2. 图解：
    <img src="合并两个有序链表1.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表2.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表3.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表4.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表5.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表6.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表7.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表8.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
3. 复杂度：
    - 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度；因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次；因此，时间复杂度取决于合并后的链表长度，即 O(n+m)；
    - 空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度；递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度；结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)；
4. 代码实现：
    ```TS
    function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
      if (list1 === null) {
        return list2;
      } else if (list2 === null) {
        return list1;
      } else if (list1.val < list2.val) {
        list1.next = mergeTwoLists(list1.next, list2);
        return list1;
      } else {
        list2.next = mergeTwoLists(list1, list2.next);
        return list2;
      }
    };
    ```
#### 同类型
1. [合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/)


### [合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)
1. 分治图解：
    <img src="合并K个升序链表.jpg" width="600px" height="auto" class="lazy-load" title="合并K个升序链表"/>
2. 代码实现：
    ```TS
    function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
      if (lists.length === 0) return null;

      return mergeLists(lists, 0, lists.length - 1);
    }

    // 归并排序的思路 二分的思路
    function mergeLists(lists: Array<ListNode | null>, start: number, end: number): ListNode {
      if (start === end) {
        return lists[start];
      }

      // 找到中间位置，将链表数组一分为二，分别进行排序
      const mid = start + ((end - start) >> 1);
      const leftList = mergeLists(lists, start, mid);
      const rightList = mergeLists(lists, mid + 1, end);

      // 将一分为二的链表合并在一起
      return merge(leftList, rightList);
    }

    // 合并两个链表
    function merge(head1:ListNode, head2:ListNode):ListNode {
      let dmy = new ListNode(0);
      let p = dmy;

      while (head1 && head2) {
        if (head1.val <= head2.val) {
          p.next = head1;
          head1 = head1.next;
        } else {
          p.next = head2;
          head2 = head2.next;
        }
        p = p.next;
      }
      p.next = head1 ? head1 : head2;

      return dmy.next;
    }
    ```

#### 同类型
1. [合并排序链表](https://leetcode.cn/problems/vvXgSW/description/)
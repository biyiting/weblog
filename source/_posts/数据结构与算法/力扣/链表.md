---
title: 链表
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 链表
abbrlink: 2362a8ea
date: 2022-06-16 11:24:49
---

## 链表
### 链表基础
1. 为什么不直接使用数组：
    - 数组在内存中占用一段连续的空间；
    - 添加、移除会导致后续元素位移，性能开销大，时间复杂度为 0(n)；
      ```JS
      const arr = []
      console.time('perfTest')
      for (let i = 0; i < 100000; i++) {
        // arr.push(i)
        arr.unshift(i)
      }
      console.timeEnd('perfTest')
      ```
2. 概念：
    - 链表是有序的数据结构，链表中的每个部分称为节点；
    - 链表可以从首、尾、中间进行数据存取；
    - 链表的元素在内存中不必是连续的空间；
    - 优点：添加与删除不会导致其余元素位移；
    - 缺点：无法根据索引快速定位元素；
3. 单链表的存储结构：
    <img src="单链表的存储结构.jpg" width="600px" height="auto" class="lazy-load" title="单链表的存储结构"/>
4. 时间复杂度：
    - prepend：O(1)；
    - append：O(1)；
    - lookup：O(n)；
    - insert：O(1)；
    - delete：O(1)；
5. 小结：
    - 获取、修改元素时，数组效率高；
    - 添加、删除元素时，链表效率高；

### 如何给链表加速
1. 跳表（升维、空间换时间）
    - 跳表，又叫做跳跃表、跳跃列表，在有序链表的基础上增加了“跳跃”的功能；
    - 跳表在原来的有序链表上加上了多级索引，通过索引来快速查找；可以支持快速的删除、插入和查找操作；
    - 跳表实际上是一种增加了前向指针的链表，是一种随机化的数据结构；
2. 跳表的数据结构图型：
    - 如何提高链表的线性查找的效率？
      <img src="如何提高链表的线性查找的效率.jpg" width="600px" height="auto" class="lazy-load" title="如何提高链表的线性查找的效率？"/>
    - 如何进一步提高链表的线性查找的效率？
      <img src="如何进一步提高链表的线性查找的效率.jpg" width="600px" height="auto" class="lazy-load" title="如何进一步提高链表的线性查找的效率？"/>
    - 增加多级索引：索引级数为 log2n ；
      <img src="增加多级索引.jpg" width="600px" height="auto" class="lazy-load" title="增加多级索引"/>
3. 跳表查询的时间复杂度：O(logn)
    - 索引个数：n/2、n/4、n/8、...第 k 级索引节点个数为 n/(2k);
    - 假设索引有 h 级，最高级索引有 2 个节点，即 n/2h = 2，h = log2n - 1；
    - 则时间复杂度为 O(logn)；
4. 跳表查询的空间复杂度：O(n)
    - 原始链表大小为 n，每 2 个节点抽一个，每层节点数：n/2、n/4、......8、4、2；
    - 原始链表大小为 n，每 3 个节点抽一个，每层节点数：n/3、n/9、......9、3、1；
    - 则空间复杂度为 O(n);
5. 现实中跳表的形态：
    <img src="现实中跳表的形态.jpg" width="600px" height="auto" class="lazy-load" title="现实中跳表的形态"/>

    - 由于跳表的增删操作，索引不是那么连续规律的；
    - 维护成本较高，增加删除要更新一遍索引；

### 单链表的实现
1. 实现以下功能：
    - 节点类：value、next
    - 链表类：
      - addAtTail()： 尾部添加节点；
      - addAtHead()： 头部添加节点；
      - addAtIndex()： 指定位置添加节点；
      - get()：获取节点；
      - removeAtIndex()： 删除指定节点；
2. 示例代码：
    ```JS
    // 节点类
    class LinkedNode {
      constructor(value) {
        this.value = value
        // 用于存储下一个节点的引用
        this.next = null
      }
    }

    // 链表类
    class LinkedList {
      constructor() {
        this.count = 0 // 单链表的长度
        this.head = null
      }

      // 添加节点 (尾）
      addAtTail(value) {
        // 创建新节点
        const node = new LinkedNode(value)
        // 检测链表是否存在数据
        if (this.count === 0) {
          this.head = node
        } else {
          // 找到链表尾部节点，将最后一个节点的 next 设置为 node
          let cur = this.head
          while (cur.next != null) {
            cur = cur.next
          }
          cur.next = node
        }
        this.count++
      }

      // 添加节点（首）
      addAtHead(value) {
        const node = new LinkedNode(value)
        if (this.count === 0) {
          this.head = node
        } else {
          // 将 node 添加到 head 的前面
          node.next = this.head
          this.head = node
        }
        this.count++
      }

      // 获取节点（根据索引）
      get(index) {
        if (this.count === 0 || index < 0 || index >= this.count) {
          return
        }
        // 迭代链表，找到对应节点
        let current = this.head
        for (let i = 0; i < index; i++) {
          current = current.next
        }
        return current
      }

      // 添加节点（根据索引）
      addAtIndex(value, index) {
        if (this.count === 0 || index >= this.count) {
          return
        }
        // 如果 index <= 0，都添加到头部即可
        if (index <= 0) {
          return this.addAtHead(value)
        }
        // 后面为正常区间处理
        const prev = this.get(index - 1)
        const next = prev.next
        const node = new LinkedNode(value)
        prev.next = node
        node.next = next
        this.count++
      }

      // 删除（根据索引）
      removeAtIndex(index) {
        if (this.count === 0 || index < 0 || index >= this.count) {
          return
        }
        if (index === 0) {
          this.head = this.head.next
        } else {
          const prev = this.get(index - 1)
          prev.next = prev.next.next
        }
        this.count--
      }
    }

    // 测试代码
    const l = new LinkedList()
    l.addAtTail('a')
    l.addAtTail('b')
    l.addAtTail('c')
    ```

### 常见的链表形式
1. 双向链表（双端链表）：
    - 双向链表指的是在普通链表的基础上，增加一个用于记录上一个节点的属性 prev，可进行双向访问；
    - 图示：
      <img src="双向链表.jpg" width="600px" height="auto" class="lazy-load" title="双向链表"/>
2. 循环链表（环形链表）：
    - 链表的最后一个节点的 next 指向第一个节点，形成首尾相连的循环结构，称为循环链表；
    - 在实际中，环的结束可以为链表的任意节点；
    - 图示：
      <img src="循环链表.jpg" width="600px" height="auto" class="lazy-load" title="循环链表"/>



## 双指针
### [环形链表](https://leetcode.cn/problems/linked-list-cycle/)
#### 快慢指针
1. 解题思路：
    - 使用两个指针，fast 与 slow，它们起始都位于链表的头部；
    - 随后 slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置；
    - 如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇；
2. 复杂度：
    - 时间复杂度：O(N)，其中 N 为链表中节点的数目；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function hasCycle(head: ListNode | null): boolean {
      if (head === null || head.next === null) return false;

      // 快慢指针
      let slow = head;
      let fast = head;

      while (fast !== null) {
        // 慢指针每次移动一位
        slow = slow.next;

        // 如果满足条件，说明 fast 为尾部结点，不存在环
        if (fast.next === null) return false;

        // 快指针每次移动两位
        fast = fast.next.next;

        // slow 和 fast 相等，说明内存地址相同，有环
        if (slow === fast) return true;
      }

      return false;
    };
    ```
#### 哈希
1. 解题思路：
    - 用 Hash 进行遍历记忆，如果产生重复遍历则代表有环；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表节点数；
    - 空间复杂度：O(n)，其中 n 是链表节点数，set 缓存空间占用；
3. 代码实现：
    ```TS
    function hasCycle(head: ListNode | null): boolean {
      if (head === null) return false;

      let set: Set<ListNode> = new Set();
      let curr = head;

      while (curr !== null) {
        if (set.has(curr)) return true;

        set.add(curr);
        curr = curr.next;
      }

      return false;
    };
    ```


### [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
#### 快慢指针
1. 解题思路：
    - 使用两个指针，fast 与 slow：它们起始都位于链表的头部；随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置；如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇；
    - 如下图所示：
      <img src="环形链表II.jpg" width="600px" height="auto" class="lazy-load" title="环形链表II"/>

    - 推导：
      - 设链表中环外部分的长度为 a，slow 指针进入环后，又走了 b 的距离与 fast 相遇，此时，fast 指针已经走完了环的 n 圈，因此：fast 走过的总距离为 a + n(b + c) + b => a + (n + 1)b + nc；slow 走过的总距离为 a + b；
      - 根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍，则有 a + (n + 1)b + nc = 2(a + b) ⟹ a = c + (n − 1)(b + c)；
      - 有了 a = c + (n - 1)(b + c) 的等量关系会发现：从相遇点到入环点的距离 c，加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离，即 c === a；
      - 因此，当发现 slow 与 fast 相遇时，再额外使用一个指针 ptr 起始指向链表头部，随后 ptr 和 slow 每次向后移动一个位置，最终它们会在入环点相遇；
2. 复杂度：
    - 时间复杂度：O(N)，其中 N 为链表中节点的数目；在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度；因此，总的执行时间为 O(N) + O(N) = O(N)；
    - 空间复杂度：O(1)，只使用了 slow、fast、ptr 三个指针；
3. 代码实现：
```TS
function detectCycle(head: ListNode | null): ListNode | null {
  if (head === null || head.next === null) return null;

  let slow = head;
  let fast = head;

  while (fast !== null) {
    slow = slow.next;

    if (fast.next === null) return null;
    fast = fast.next.next;

    // 检测是否有环
    if (fast === slow) {
      // 找到环的起点位置
      let ptr = head

      // pre 从 head 到环起点处的距离 === slow 到环起始节点的距离
      // 则到环起点时，pre 和 slow 相遇，即 a === c
      while (ptr !== slow) {
        ptr = ptr.next
        slow = slow.next
      }
      return ptr
    }
  }

  return null;
};
```

#### 哈希
1. 解题思路
    - 遍历链表中的每个节点，并将它记录下来；
    - 一旦遇到了此前遍历过的节点，就可以判定链表中存在环；
    - 借助哈希表可以很方便地实现；
2. 复杂度
    - 时间复杂度：O(N)，其中 N 为链表中节点的数目，恰好需要访问链表中的每一个节点；
    - 空间复杂度：O(N)，其中 N 为链表中节点的数目，需要将链表中的每个节点都保存在哈希表当中；
3. 代码实现：
    ```TS
    function detectCycle(head: ListNode | null): ListNode | null {
      if (head === null) return head;

      let set: Set<ListNode> = new Set;
      let curr = head;

      while (curr !== null) {
        if (set.has(curr)) return curr;

        set.add(curr);
        curr = curr.next;
      }

      return null;
    };
    ```
#### 同类型
1. [链表中环的入口节点](https://leetcode.cn/problems/c32eOV/)
2. [环路检测](https://leetcode.cn/problems/linked-list-cycle-lcci/description/)

### [链表的中间节点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)
1. 解题思路：
    - 用两个指针 slow 与 fast 一起遍历链表；
    - slow 一次走一步，fast 一次走两步；
    - 那么当 fast 到达链表的末尾时，slow 必然位于中间；
2. 复杂度：
    - 时间复杂度：O(N)，其中 N 是给定链表的结点数目；
    - 空间复杂度：O(1)，只需要常数空间存放 slow 和 fast 两个指针；
3. 代码实现：
    ```TS
    function middleNode(head: ListNode | null): ListNode | null {
      let fast = head;
      let slow = head;

      // fast 为 null，返回 slow 即可
      while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        slow = slow.next;
      }

      return slow;
    };
    ```


### [链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/)
1. 解题思路：
    - 初始化快慢指针 fast、slow；
    - fast 先向后移动 k 个位置，然后 fast 和 slow 再一起向后移动；
    - 当 fast 走到最后的时候，slow 的位置就是倒数第 k 个位置；
2. 复杂度：
    - 时间复杂度：O(N)，N 为链表长度；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function getKthFromEnd(head: ListNode | null, k: number): ListNode | null {
      let slow = head;
      let fast = head;

      while (k-- > 0) fast = fast.next;

      while (fast !== null) {
        fast = fast.next;
        slow = slow.next;
      }

      return slow;
    };
    ```

### [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
1. 解题思路：
    - 此题需要解决两个问题：第一个问题：找到倒数第 n 个节点；第二个问题：删除倒数第 n 个节点，首先拿到这个节点的前一个节点，则设置虚拟节点 dummyHead 指向 head，找到的倒数的第 n 个节点的下一个才是要删除的节点；
    - 初始化快慢指针指针 slow 和 fast 都指向头结点；
    - 移动 fast 向后移动 n 个位置，此时 fast 与 show 之间相隔的元素个数为 n；
    - 再同时相后移动 fast 与 slow，直到 fast 走到最后，此时 slow 的下一个节点就是要删除的倒数第 n 个元素；
    - 将 slow 的下一个节点指向下下个节点，删除倒数第 n 个元素；
2. 复杂度：
    - 时间复杂度：O(L)，其中 L 是链表的长度；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
      let dmy = new ListNode(0, head);
      let slow = dmy;
      let fast = dmy;

      // fast 向后移动 n 个位置
      while (n-- > 0) fast = fast.next;

      // fast 走到最后，slow 此时是 倒数第 n 个元素的前一个
      while (fast !== null && fast.next !== null) {
        fast = fast.next;
        slow = slow.next;
      }

      // slow 的下一个节点就是要删除的节点
      slow.next = slow.next.next;

      return dmy.next;
    };
    ```
#### 同类型
1. [删除链表的倒数第 n 个结点](https://leetcode.cn/problems/SLwz0R/description/)


### [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)
#### 双指针
1. 解题思路：
    - A+B === B+A，用双指针 pA 、pB 循环两个链表，链表 A 循环结束就循环链表 B，链表 B 循环结束就循环链表 A；
    - 当 pA == pB 时就是交点，因为两个指针移动的步数一样；
2. 复杂度：
    - 时间复杂度：O(m+n)，m、n分别是两个链表的长度；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
      if (headA === null || headB === null) return null;

      let pA = headA, pB = headB;

      // pA === pB 的时候有两种情况：
      // 1.有相交的时候 pA、pB 为 相交节点 
      // 2.没有相交的时候 pA、pB 为 null
      while (pA !== pB) {
        pA = pA === null ? headB : pA.next; // 链表A循环结束就循环链表B 
        pB = pB === null ? headA : pB.next; // 链表B循环结束就循环链表A 
      }

      return pA; // 当pA == pB时就是交点
    };
    ```

#### 哈希
1. 解题思路：
    - 将链表 A 存入 set 中，再迭代链表 B，判断节点是否在 set 中存在；
    - 第一个相同的节点就是重合的节点；
2. 复杂度：
    - 时间复杂度：O(m+n)，m、n分别是两个链表的长度；
    - 空间复杂度：O(m)；
3. 代码实现：
    ```TS
    function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
      let set: Set<ListNode> = new Set;

      let curr = headA;
      while (curr !== null) {
        set.add(curr);
        curr = curr.next;
      }

      curr = headB;
      while (curr !== null) {
        if (set.has(curr)) return curr;
        curr = curr.next;
      }

      return null;
    };
    ```
#### 同类型
1. [两个链表的第一个重合节点](https://leetcode.cn/problems/3u1WK4/description/)
2. [两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

### [删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/description/)
#### 双指针+虚拟头节点+迭代
1. 解题思路：
    - 初始化一个 dmy 虚拟节点的 next 指向 head，初始化 prev 和 curr 两个节点，prev 指向 dmy，curr 指向 dmy.next 也就是 head；
    - 判断 curr 的值是否等于 val，等于 val 则直接 prev.next = curr.next 删除 curr 节点，直接跳出；
    - 最后返回结果 dmy.next；
2. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function deleteNode(head: ListNode | null, val: number): ListNode | null {
      // 因为 head 有可能是要删除的元素，所以借助虚拟来删除
      let dmy = new ListNode(0, head);
      let prev = dmy;
      let curr = head;

      while (curr !== null) {
        if (curr.val === val) {
          prev.next = curr.next;
          break;
        }
        prev = curr;
        curr = curr.next;
      }

      return dmy.next;
    };
    ```

#### 虚拟节点+迭代
1. 解题思路：
    - 初始化一个哨兵节点（虚拟节点）dmy，然后指向 head，初始化 curr 节点指向 dmy；
    - 每次向后移动 curr，判断 curr.next 的值是否等于 val，相等则删除 curr.next 节点；
    - 最后返回结果 dmy.next；
2. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function deleteNode(head: ListNode | null, val: number): ListNode | null {
      let dmy = new ListNode(0, head);
      let curr = dmy;

      while (curr && curr.next !== null) {
        if (curr.next.val === val) {
          curr.next = curr.next.next;
          break;
        }
        curr = curr.next;
      }

      return dmy.next;
    };
    ```

#### 递归
1. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(n)；
2. 代码实现：
    ```TS
    function deleteNode(head: ListNode | null, val: number): ListNode | null {
      // 递归的终止条件：head 等于空的时候，直接返回 head，因为一个空的链表是没法删除的
      if (head === null) return head;

      // head 结点的值等于 val，直接返回 head 结点的下一个结点，相当于删除了当前节点
      if (head.val === val) return head.next;

      // 递归调用判断下一个节点是否等于 val
      head.next = deleteNode(head.next, val);

      return head;
    };
    ```


### [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)
#### 双指针
1. 解题思路：
    - 初始化 prev 和 curr 两个节点，prev 指向 head，curr 指向 head.next；
    - 判断 curr 的值是否等于 prev：等于则直接 prev.next = curr.next 删除 curr 节点，curr 继续向后移动一个位置；不等于则将 prev 向后移动一个位置，curr 继续向后移动一个位置；
    - 直到 curr 走到最后，返回结果 head；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的长度；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function deleteDuplicates(head: ListNode | null): ListNode | null {
      if (head === null || head.next === null) return head;

      let prev: ListNode = head;
      let curr: ListNode = head.next;

      while (curr !== null) {
        if (prev.val === curr.val) {
          // 因为有多个重复的元素，所以要删除多次
          // 直接删除重复节点 curr
          prev.next = curr.next;
        } else {
          prev = prev.next;
        }

        curr = curr.next;
      }

      return head;
    }
    ```

#### 虚拟头节点+迭代
1. 解题思路：
    - 定义虚拟头结点 dmy 指向 head，指定 cur 指针指向头部 head；
    - 当 cur 和 cur.next 为 null 循环结件，当二者有一个不存在时说明链表没有去重复的必要了；
      - 当 cur.val 和 cur.next.val 相等时说明需要去重；
      - 如果不相等则 cur 移动到下一个位置继续循环；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的长度；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function deleteDuplicates(head: ListNode | null): ListNode | null {
      if (head === null || head.next === null) return head;

      let dmy: ListNode = new ListNode(-1, head);
      let curr: ListNode = dmy.next;

      while (curr && curr.next) {
        if (curr.val === curr.next.val) {
          curr.next = curr.next.next;
        } else {
          curr = curr.next;
        }
      }

      return dmy.next;
    }
    ```

#### 递归
1. 解题思路：
    - deleteDuplicates 递归执行直到链表的最后，从后向前处理；
    - 再判断 head.val === head.next.val，相等则删除 head.next 节点；
    - 返回结果 head；
2. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(n)；
3. 代码实现：
    ```TS
    function deleteDuplicates(head: ListNode | null): ListNode | null {
      if (head === null) return head;

      if (head.next !== null) {
        head.next = deleteDuplicates(head.next);
        if (head.val === head.next.val) {
          head.next = head.next.next
        }
      }

      return head;
    }
    ```


### [删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/)
#### 虚拟头结点+双指针
1. 解题思路：
    - 初始化哑结点（哨兵节点/虚拟节点）dmy 的 next 指向 head，初始化快慢指针 fast、slow 的值分别为 dmy、head；
    - fast 指针用来寻找重复的节点，只要 fast 和 fast.next 的值相等，fast 则向后移动；
    - 原本 fast 和 slow 指针只相差一个位置，当出现重复的值 fast 就会向后移动，fast 和 slow 就会相差多个位置，这时 slow.next = fast.next 删除重复的值；
    - 最后返回结果 dmy.next；
2. 复杂度：
    - 时间复杂度：O(N)，对链表每个节点遍历了一次；
    - 空间复杂度：O(1)，只使用了常量的空间；
3. 代码实现：
    ```TS
    function deleteDuplicates(head: ListNode | null): ListNode | null {
      let dmy = new ListNode(0, head);

      // 初始化快慢指针 slow、fast，分别指向 dmy、head
      let slow = dmy;
      let fast = dmy.next;

      // 终止条件：fast 走到链表最后
      while (fast !== null) {
        // 若 fast 和下一个节点值相等，fast 向后移动
        while (fast.next !== null && fast.val === fast.next.val) fast = fast.next;

        // 原本 slow 和 fast 只相差一个位置，只要相差多个位置就说明「出现重复」
        if (slow.next === fast) {
          slow = slow.next;
        } else {
          // 删除重复节点
          slow.next = fast.next;
        }

        fast = fast.next;
      }

      return dmy.next
    };
    ```

#### 递归
1. 解题思路：
    - 终止条件：如果 head 为空，那么肯定没有值出现重复的节点，直接返回 head；如果 head.next 为空，那么说明链表中只有一个节点，也没有值出现重复的节点，也直接返回 head；
    - 如果 head.val != head.next.val ，说明头节点的值不等于下一个节点的值，所以当前的 head 节点必须保留；但是 head.next 节点要不要保留呢？还不知道，需要对 head.next 进行递归，即对 head.next 作为头节点的链表，去除值重复的节点，所以 head.next = self.deleteDuplicates(head.next)；
    - 如果 head.val == head.next.val ，说明头节点的值等于下一个节点的值，所以当前的 head 节点必须删除，并且 head 之后所有与 head.val 相等的节点也都需要删除；删除到哪个节点为止呢？需要用 move 指针一直向后遍历寻找到与 head.val 不等的节点。此时 move 之前的节点都不保留了，因此返回 deleteDuplicates(move);
2. 复杂度：
    - 时间复杂度：O(N)，每个节点访问了一次；
    - 空间复杂度：O(N)，递归调用的时候会用到了系统的栈；
3. 代码实现：
    ```TS
    function deleteDuplicates(head: ListNode | null): ListNode | null {
      // 只有一个节点或没有节点 直接返回
      if (head == null || head.next == null) return head;

      // 递归会有两种情况：1.head和head.next值相等 2.head和head.next值不相等
      if (head.next.val === head.val) {
        // 1.当 head 和 head.next 的值相同，则一直向后查找
        let temp = head.next;
        while (temp != null && head.val == temp.val) temp = temp.next;

        // 返回删除重复项后的链表
        return deleteDuplicates(temp);
      } else {
        // 2.head 和 head.next 的值不同，继续向后递归（会出现两种情况）
        head.next = deleteDuplicates(head.next);
      }

      return head;
    };
    ```


### [回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/)
1. 解题思路：
    - 第一步：初始化快慢指针 slow、fast 都指向 head，fast 每次走 2 步，slow 每次走 1 步，当 fast 走到最后的时候，slow 位于中间位置，slow 在移动的时候不断反转，反转后为 prev；
    - 第二步：判断链表长度的奇偶性，奇数的情况下 slow 再向后移动一步；
    - 第三步：slow 和 prev 为链表前后半部分的头节点，判断 slow 和 prev 开始到结尾的值，都相同返回 true，否则返回 false；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的长度，需要使用快慢指针遍历链表，遍历链表的前一半并反转，以及反转后遍历链表，每次遍历的时间复杂度都是 O(n)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function isPalindrome(head: ListNode | null): boolean {
      let fast = head;
      let slow = head;
      let prev = null

      // 1.fast 走 2 步，slow 走 1 步，fast 走到最后的时候，slow 位于中间，反转 slow 前的链表
      while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        // 反转链表
        let next = slow.next;
        slow.next = prev;
        prev = slow
        slow = next;
      }

      // 2.fast !== null，说明链表为奇数，去掉中间的公共节点
      if (fast !== null) slow = slow.next;

      // 3.prev 为反转的链表头结点，slow 为链表的后半部分，判断 prev、slow 开始到结尾的节点值
      while (prev !== null && slow !== null) {
        if (prev.val !== slow.val) return false;

        prev = prev.next;
        slow = slow.next;
      }

      return true;
    };
    ```
#### 同类型
1. [回文链表](https://leetcode.cn/problems/palindrome-linked-list-lcci/description/)
2. [回文链表](https://leetcode.cn/problems/aMhZSa/)

### [分隔链表](https://leetcode.cn/problems/partition-list/description/)
1. 解题思路：
    - 初始化哑结点 dmy 和快慢指针 fast、slow,slow 指针向后迭代，找到最后一个小于 x 的节点；
    - fast 从 slow 向后寻找小于 x 的节点：
      - 若找到小于 x 的节点则将该节点取出来放在 slow 后面，slow 向后移动一个位置，始终保持自己是最后一个小于 x 的节点；
      - 若未找到则 fast 继续向后迭代；
    - 返回结果 dmy.next；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的长度；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function partition(head: ListNode | null, x: number): ListNode | null {
      // 初始化哨兵节点 dmy.next 指向 head
      let dmy = new ListNode(-1, head);
      let slow = dmy;
      let fast = null;

      // 1.找到最后一个 slow 的值小于 x 的节点
      while (slow !== null && slow.next !== null) {
          if (slow.next.val >= x) break;
          slow = slow.next;
      }

      // 2.fast 从 slow 向后迭代
      fast = slow;
      while (fast !== null && fast.next !== null) {
        if (fast.next.val < x) {
          // 2.1 遇到 fast.next.val 小于 x，将该节点 tmp 取出来，放入 slow 后面
          let tmp = fast.next;
          fast.next = fast.next.next;

          // 将 tmp 放入 slow 后，slow 向后移动一位
          tmp.next = slow.next
          slow.next = tmp;
          slow = slow.next;
        } else {
          // 2.2 遇到 fast.next.val 不小于 x，继续向后查找
          fast = fast.next;
        }
      }

      return dmy.next;
    };
    ```



## 递归
### [反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
#### 递归
1. 图解：
    <img src="反转链表1.jpg" width="600px" height="auto" class="lazy-load" title="反转链表"/>
    <img src="反转链表2.jpg" width="600px" height="auto" class="lazy-load" title="反转链表"/>
2. 复杂度：
    - 时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)；
    - 空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层；
3. 代码实现：
    ```TS
    function reverseList(head: ListNode | null): ListNode | null {
      // 递归终止条件
      if (head === null || head.next === null) return head;

      // 递归到最后一个节点，再从后向前进行反转（执行下面的代码）
      const prev = reverseList(head.next)

      // 反转
      head.next.next = head;
      // 断开原有指向，链表的最后节点指向 null
      head.next = null;

      // 并返回反转之后的头结点
      return prev;
    };
    ```

#### 迭代
1. 解题思路：
    - 在遍历链表时，将当前节点的 next 指针改为指向前一个节点；
    - 由于节点没有引用其前一个节点，因此必须事先存储其前一个节点；
    - 在更改引用之前，还需要存储后一个节点；
    - 最后返回新的头引用；
2. 图解：
    <img src="反转链表-迭代.jpg" width="600px" height="auto" class="lazy-load" title="反转链表"/>
3. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的长度，需要遍历链表一次；
    - 空间复杂度：O(1)；
4. 代码实现：
    ```TS
    function reverseList(head: ListNode | null): ListNode | null {
      // 记录上一个节点
      let prev = null
      // 记录当前节点
      let cur = head

      // 当 cur 是节点时，进行迭代
      while (cur) {
        // 先保存当前节点的下一个节点
        const next = cur.next
        // 反转链表
        cur.next = prev
        //  向下移动链表
        prev = cur
        // 取出存储的节点，继续循环
        cur = next
      }

      return prev
    };
    ```

#### 同类型
1. [反转链表](https://leetcode.cn/problems/UHnkqh/description/)
2. [反转链表](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/)


### [反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)
1. 解题思路：递归+反转区间链表+反转链表前 n 个节点
    - 此题是反转 [left，right] 区间内的链表；
    - reverseN 反转链表前 n 个节点；
      <img src="反转链表II.jpg" width="600px" height="auto" class="lazy-load" title="反转链表II"/>
    - reverseBetween 一直递归，直到 --left 为 1 的时候，说明此时可以直接 reverseN 反转链表前 n 个节点；
2. 复杂度：
    - 时间复杂度：O(N)；
    - 空间复杂度：O(N)；
3. 代码实现：
    ```TS
    let successor: ListNode = null; // 后驱节点

    // 反转链表的前 n 个节点
    function reverseN(head: ListNode, n: number): ListNode {
      // n ===1 说明当前 head 节点是第 n 个节点
      if (n === 1) {
        // 记录 n 的下一个节点
        successor = head.next;
        return head;
      }
      // 递归到 n 个节点，再从后向前进行反转（执行下面的代码）
      let last = reverseN(head.next, --n);
      head.next.next = head;
      // 反转前 n 个节点后的链表，与 n 后的链表连接在一起
      head.next = successor;
      return last;
    }

    // 反转 [m, n] 区间的链表（链表索引从 1 开始）
    function reverseBetween(head: ListNode | null, m: number, n: number): ListNode | null {
      // base case：反转前 n 个节点
      if (m === 1) return reverseN(head, n);

      // 前进到反转的起点，m===1 触发 base case
      head.next = reverseBetween(head.next, --m, --n);

      return head;
    };
    ```

### [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
#### 递归
1. 解题思路：
    - 第一步：定义两个指针 head、next 分别指向第一个和第二个节点；
    - 第二步：head 指针指向下下个节点；
    - 第三步：next 指针指向 head 节点，反转；
2. 图解：
    <img src="两两交换链表中的节点-递归.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-递归"/>
3. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的节点数量，需要对每个节点进行更新指针的操作；
    - 空间复杂度：O(n)，其中 n 是链表的节点数量，空间复杂度主要取决于递归调用的栈空间；
4. 代码实现：
    ```TS
    function swapPairs(head: ListNode | null): ListNode | null {
      if (head === null || head.next === null) return head;

      let next = head.next;
      head.next = swapPairs(head.next.next);
      next.next = head;

      // 返回反转后的头节点
      return next;
    };
    ```

#### 递归+stack
1. 解题思路：
    - 利用一个 stack，然后不断迭代链表，每次取出两个节点放入 stack 中，再从 stack 中拿出两个节点；
    - 借助 stack 后进先出的特点，放进去的时候是 1、2 ，拿出来的时候就是 2、1 两个节点了；
    - 再把这两个节点串联起来，重复这个逻辑遍历完整个链表，就可以做到两两反转的效果了；
2. 图解：
    <img src="两两交换链表中的节点-递归stack.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-递归stack"/>
3. 复杂度：
    - 空间复杂度还是 O(1)：虽然用到了 stack，但因为只存了两个元素，所以空间复杂度还是 O(1)；
    - 时间复杂度是 O(n)；
4. 代码实现：
    ```TS
    function swapPairs(head: ListNode | null): ListNode | null {
      if (head === null || head.next === null) return head;
      let stack = [];

      // 将 node1、node2 入栈
      stack.push(head);
      stack.push(head.next);

      // 出栈顺序为 node2、node1
      let node2 = stack.pop();
      let node1 = stack.pop();

      // node2 和 node1 反转
      node1.next = swapPairs(node2.next);
      node2.next = node1;

      return node2;
    };
    ```

#### 迭代
1. 解题思路：
    - 创建哑结点 dummyHead，令 dummyHead.next = head，temp 表示当前到达的节点，初始时 temp = dummyHead，每次需要交换 temp 后面的两个节点；
    - 如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换；
    - 否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点；
2. 图解：
    <img src="两两交换链表中的节点-迭代1.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
    <img src="两两交换链表中的节点-迭代2.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
    <img src="两两交换链表中的节点-迭代3.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
    <img src="两两交换链表中的节点-迭代4.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
    <img src="两两交换链表中的节点-迭代5.jpg" width="600px" height="auto" class="lazy-load" title="两两交换链表中的节点-迭代"/>
3. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的节点数量，需要对每个节点进行更新指针的操作；
    - 空间复杂度：O(1)；
4. 代码实现
    ```TS
    function swapPairs(head: ListNode | null): ListNode | null {
      const dmy = new ListNode(0, head);
      // 定义 curr 当前指针
      let curr = dmy;

      while (curr.next !== null && curr.next.next !== null) {
        // 定义 node1 和 node2 指针
        let node1 = curr.next;
        let node2 = curr.next.next;

        // 反转 node1 node2 指向
        curr.next = node2;
        node1.next = node2.next;
        node2.next = node1;

        // 移动 curr 指针
        curr = curr.next.next
      }

      return dmy.next;
    };
    ```


### [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)
#### 递归+拆分
1. 图解：
    <img src="K 个一组翻转链表.jpg" width="600px" height="auto" class="lazy-load" title="K 个一组翻转链表"/>
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 为链表的长度，head 指针会在 O(k/n) 个节点上停留，每次停留需要进行一次 O(k) 的翻转操作；
    - 空间复杂度：O(1)，只需要建立常数个变量；
3. 代码实现：
    ```TS
    function reverseKGroup(head: ListNode | null, k: number): ListNode | null {
      if (head === null || k === 1) return head;

      let start = head;
      let end = head;
      // 不足 k 个，不需要反转，base case
      for (let i = 0; i < k; i++) {
        if (end == null) return head;
        end = end.next;
      }

      // 反转区间 [start, end) 的链表，并返回反转后的头节点
      let newHead = reverse(start, end);

      // 递归反转后续链表并连接起来
      start.next = reverseKGroup(end, k);

      return newHead;
    };

    // 反转链表的前 n 个节点，[start, end)
    function reverse(start: ListNode, end: ListNode): ListNode {
      let prev = null;
      let curr = start;

      // 基于反转整个链表，while 终止的条件改成 curr ！== end
      while (curr !== end) {
        let next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
      }

      // 返回反转后的头结点
      return prev;
    }
    ```

#### 递归+栈
1. 复杂度：
    - 时间复杂度：O(n)，其中 n 是链表的节点数量，需要对每个节点进行更新指针的操作；
    - 空间复杂度：O(n)，其中 n 是链表的节点数量；
2. 实现代码：
    ```TS
    function reverseKGroup(head: ListNode | null, k: number): ListNode | null {
      if (k === 1 || head === null || head.next === null) return head;

      // k 大于链表长度，直接返回 head
      let curr = head;
      for (let i = 0; i < k - 1; i++) {
        curr = curr.next;
        if (curr === null) return head;
      }

      // 将 k 个节点 依次入栈，node1、node2、node3...，nodek
      let stack = [];
      curr = head;
      for (let i = 0; i < k; i++) {
        stack.push(curr)
        curr = curr.next;
      }

      let first = stack[0];
      let last = stack[stack.length - 1];
      // 开始下一轮反转
      first.next = reverseKGroup(last.next, k);

      // 将 k 个节点 依次出栈，nodek、...，node2，node1
      curr = stack.pop();
      while (stack.length) {
        curr.next = stack.pop();
        curr = curr.next;
      }

      return last;
    };
    ```


## 合并
### [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)
#### 迭代+虚拟头结点
1. 解题思路：
    - 定义一个哨兵节点 dummy，使用 dummy->next 来保存需要返回的头节点；
    - 判断 l1 和 l2 哪个更小，就把这个节点接到 dummy 下一个；
    - 直到有一边为 null ，即可将另一边剩余的都接到 dummy 上；
2. 复杂度：
    - 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度；因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和；所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)；
    - 空间复杂度：O(1)，只需要常数的空间存放若干变量；
3. 代码实现：
    ```TS
    function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
      let dmy = new ListNode();
      let curr = dmy;

      while (list1 !== null && list2 !== null) {
        if (list1.val < list2.val) {
          curr.next = list1;
          list1 = list1.next;
        } else {
          curr.next = list2;
          list2 = list2.next;
      }
        curr = curr.next;
      }

      if (list1 === null) curr.next = list2;
      if (list2 === null) curr.next = list1;

      return dmy.next;
    };
    ```

#### 递归
1. 解题思路：
    - 终止条件：当两个链表都为空时，表示我们对链表已合并完成；
    - 如何递归：判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果；（调用递归）
2. 图解：
    <img src="合并两个有序链表1.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表2.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表3.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表4.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表5.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表6.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表7.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
    <img src="合并两个有序链表8.jpg" width="600px" height="auto" class="lazy-load" title="合并两个有序链表"/>
3. 复杂度：
    - 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度；因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次；因此，时间复杂度取决于合并后的链表长度，即 O(n+m)；
    - 空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度；递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度；结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)；
4. 代码实现：
    ```TS
    function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
      if (list1 === null) {
        return list2;
      } else if (list2 === null) {
        return list1;
      } else if (list1.val < list2.val) {
        list1.next = mergeTwoLists(list1.next, list2);
        return list1;
      } else {
        list2.next = mergeTwoLists(list1, list2.next);
        return list2;
      }
    };
    ```
#### 同类型
1. [合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/)


### [合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)
1. 分治图解：
    <img src="合并K个升序链表.jpg" width="600px" height="auto" class="lazy-load" title="合并K个升序链表"/>
2. 代码实现：
    ```TS
    function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
      if (lists.length === 0) return null;

      return mergeLists(lists, 0, lists.length - 1);
    }

    // 归并排序的思路 二分的思路
    function mergeLists(lists: Array<ListNode | null>, start: number, end: number): ListNode {
      if (start === end) {
        return lists[start];
      }

      // 找到中间位置，将链表数组一分为二，分别进行排序
      const mid = start + ((end - start) >> 1);
      const leftList = mergeLists(lists, start, mid);
      const rightList = mergeLists(lists, mid + 1, end);

      // 将一分为二的链表合并在一起
      return merge(leftList, rightList);
    }

    // 合并两个链表
    function merge(head1:ListNode, head2:ListNode):ListNode {
      let dmy = new ListNode(0);
      let p = dmy;

      while (head1 && head2) {
        if (head1.val <= head2.val) {
          p.next = head1;
          head1 = head1.next;
        } else {
          p.next = head2;
          head2 = head2.next;
        }
        p = p.next;
      }
      p.next = head1 ? head1 : head2;

      return dmy.next;
    }
    ```

#### 同类型
1. [合并排序链表](https://leetcode.cn/problems/vvXgSW/description/)
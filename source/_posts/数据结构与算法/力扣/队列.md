---
title: 队列
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 队列
abbrlink: b6c47025
date: 2022-07-08 11:24:49
---
## 队列基础
### 队列的定义
1. 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表；
2. 与栈相反，队列是一种先进先出（First In First Out，FIFO）的线性表；
3. 与栈相同的是，队列也是一种重要的线性结构，实现一个队列同样需要顺序表和链表作为基础；
		
### 队列的存储结构
1. 链式存储结构
    <img src="链式存储结构.jpg" width="400px" height="auto" class="lazy-load" title="链式存储结构"/>
2. 顺序存储结构
    <img src="顺序存储结构.jpg" width="400px" height="auto" class="lazy-load" title="顺序存储结构"/>

### 队列的实现
1. 实现以下功能：
    - enqueue()： 入队；
    - dequeue()： 出队；
    - top()： 获取队首值；
    - size()：获取队列的元素个数；
    - clear()： 清空队列；
2. 示例代码：（基于数组）
    ```JS
    class Queue {
      constructor() {
        // 用于存储队列数据
        this.queue = []
        this.count = 0
      }
    
      // 入队方法
      enQueue(item) {
        this.queue[this.count++] = item
      }
    
      // 出队方法
      deQueue() {
        if (this.isEmpty()) {
          return
        }
        // 删除 queue 的第一个元素，值会被删除，位置仍然被占用
        // delete this.queue[0]
    
        // 利用 shift() 移除数组的第一个元素
        this.count--
        return this.queue.shift()
      }
    
      isEmpty() {
        return this.count === 0
      }
    
      // 获取队首元素值
      top() {
        if (this.isEmpty()) {
          return
        }
        return this.queue[0]
      }
    
      size() {
        return this.count
      }
    
      clear() {
        // this.queue = []
        this.length = 0
        this.count = 0
      }
    }

    const q = new Queue()
    ```
3. 示例代码：（基于对象）
    ```JS
    class Queue {
      constructor() {
        this.queue = {}
        this.count = 0
        // 用于记录队首的键
        this.head = 0
      }
    
      // 入队方法
      enQueue(item) {
        this.queue[this.count++] = item
      }
    
      // 出队方法
      deQueue() {
        if (this.isEmpty()) {
          return
        }
    
        const headData = this.queue[this.head]
        delete this.queue[this.head]
        this.head++
        this.count--
        return headData
      }
    
      isEmpty() {
        return this.count === 0
      }
    
      // 获取队首元素值
      top() {
        if (this.isEmpty()) {
          return
        }
        return this.queue[this.head]
      }
    
      size() {
        return this.count
      }
    
      clear() {
        this.queue = {}
        this.count = 0
        this.head = 0
      }
    }
    
    const q = new Queue()
    ```

### 双端队列
1. 双端队列的定义：
    - 双端队列（double-ended queue）指的是允许同时从队尾与队首两端进行存取操作的队列，操作更加灵活；
    - 与数组操作十分相似，只是不允许在数组两端以外的位置进行存取操作；
2. 实现以下功能：
    - addFront()/addBack()： 在首尾入队；
    - removeFront()/removeBack()： 在首尾出队；
    - frontTop()/backTop()： 获取在首尾值；
    - size()：获取双端队列的元素个数；
3. 示例代码：（基于对象）
    ```JS
    class Deque {
      constructor() {
        this.queue = {}
        this.count = 0 
        this.head = 0
      }

      // 队首添加
      addFront(item) {
        this.queue[--this.head] = item
      }

      // 队尾添加
      addBack(item) {
        this.queue[this.count++] = item
      }

      // 队首删除
      removeFront() {
        if (this.isEmpty()) {
          return
        }
        const headData = this.queue[this.head]
        delete this.queue[this.head++]
        return headData
      }

      // 队尾删除
      removeBack() {
        if (this.isEmpty()) {
          return
        }
        const backData = this.queue[this.count - 1]
        delete this.queue[--this.count]
        // this.count-- 与 上一步 this.count - 1 合并
        return backData
      }

      // 获取队首值
      frontTop() {
        if (this.isEmpty()) {
          return
        }
        return this.queue[this.head]
      }

      // 获取队尾值
      backTop() {
        if (this.isEmpty()) {
          return
        }
        return this.queue[this.count - 1]
      }

      isEmpty() {
        return this.size() === 0
      }

      size() {
        return this.count - this.head
      }
    }

    const deq = new Deque()
    ```


## [队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)
### 单调的双端队列
1. 解题思路：维护一个单调的双端队列
    - 本算法基于问题的一个重要性质：当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响。
    - 举个例子，如果向队列中插入数字序列 1 1 1 1 2，那么在第一个数字 2 被插入后，数字 2 前面的所有数字 1 将不会对结果产生影响。因为按照队列的取出顺序，数字 2 只能在所有的数字 1 被取出之后才能被取出，因此如果数字 1 如果在队列中，那么数字 2 必然也在队列中，使得数字 1 对结果没有影响。
    - 按照上面的思路，可以设计这样的方法：从队列尾部插入元素时，可以提前取出队列中所有比这个元素小的元素，使得队列中只保留对结果有影响的数字。这样的方法等价于要求维持队列单调递减，即要保证每个元素的前面都没有比它小的元素。
    - 那么如何高效实现一个始终递减的队列呢？只需要在插入每一个元素 value 时，从队列尾部依次取出比当前元素 value 小的元素，直到遇到一个比当前元素大的元素 value' 即可。
      - 上面的过程保证了只要在元素 value 被插入之前队列递减，那么在 value 被插入之后队列依然递减；
      - 而队列的初始状态（空队列）符合单调递减的定义；
      - 由数学归纳法可知队列将会始终保持单调递减；
    - 上面的过程需要从队列尾部取出元素，因此需要使用双端队列来实现。另外也需要一个辅助队列来记录所有被插入的值，以确定 pop_front 函数的返回值。
    - 保证了队列单调递减后，求最大值时只需要直接取双端队列中的第一项即可；
2. 复杂度：
    - 时间复杂度：O(1)（插入，删除，求最大值）：删除操作于求最大值操作显然只需要 O(1) 的时间，而插入操作虽然看起来有循环，做一个插入操作时最多可能会有 n 次出队操作。但要注意，由于每个数字只会出队一次，因此对于所有的 n 个数字的插入过程，对应的所有出队操作也不会大于 n 次。因此将出队的时间均摊到每个插入操作上，时间复杂度为 O(1)；
    - 空间复杂度：O(n)，需要用队列存储所有插入的元素；
3. 代码实现：
    ```JS
    var MaxQueue = function() {
      // 存储队列数据
      this.queue = {}
      // 准备队列相关的数据
      this.headQ = this.countQ = 0

      // 双端队列维护最大值（每个阶段的最大值）
      this.deque = {}
      this.headD = this.countD = 0
    };


    /** 队尾入队
      * @param {number} value
      * @return {void}
      */
    MaxQueue.prototype.push_back = function(value) {
      // 数据在 queue 入队
      this.queue[this.countQ++] = value
      // 检测是否可以将数据添加到双端队列
      //   - 队列不能为空
      //   - value 大于队尾值
      while (!this.isEmptyDeque() && value > this.deque[this.countD - 1]) {
        // 删除当前队尾值
        delete this.deque[--this.countD]
      }
      // 将 value 入队
      this.deque[this.countD++] = value
    };


    /** queue 队首出队
      * @return {number}
      */
    MaxQueue.prototype.pop_front = function() {
      if (this.isEmptyQueue()) {
        return - 1
      }
      // 比较 deque 与 queue 的队首值，如果相同，deque 出队，否则 deque 不操作
      if (this.queue[this.headQ] === this.deque[this.headD]) {
        delete this.deque[this.headD++]
      }
      // 给 queue 出队，并返回
      const frontData = this.queue[this.headQ]
      delete this.queue[this.headQ++]
      return frontData
    };


    /** 获取队列最大值
      * @return {number}
      */
    MaxQueue.prototype.max_value = function() {
      if (this.isEmptyDeque()) {
        return -1
      }
      // 返回 deque 队首值即可
      return this.deque[this.headD]
    };


    /** 检测队列 deque 是否为空
      * @returns 
      */
    MaxQueue.prototype.isEmptyDeque = function () {
      return !(this.countD - this.headD)
    };


    /** 检测队列 Queue 是否为空
      * @returns 
      */
    MaxQueue.prototype.isEmptyQueue = function () {
      return !(this.countQ - this.headQ)
    };


    /**
     * Your MaxQueue object will be instantiated and called as such:
     * var obj = new MaxQueue()
     * var param_1 = obj.max_value()
     * obj.push_back(value)
     * var param_3 = obj.pop_front()
     */
    ```
### 单调队列
1. 解题思路：
    - 维护一个单调递减的队列 max_queue；
    - push_back：max_queue 为空则直接入队，不为空要判断队尾的元素和新增的元素的大小；
      - 队尾的元素 < 新增元素，删掉队尾元素直到队尾元素小于新增的元素位置（维护单调递减队列）；
      - 队尾的元素 > 新增元素，直接入队；
    - pop_front：判断 queue 出队的元素是否等于 max_queue 的队列头元素，等于则一起出队，否则不出队；
    - max_value：如果队列是空的返回 -1，否则返回 max_queue 的第一个元素；
2. 复杂度：
    - 时间复杂度：O(1)，max_value(), push_back(), pop_front() 方法的均摊时间复杂度均为 O(1) ；
    - 空间复杂度：O(N)，当元素个数为 N 时，最差情况下 max_queue 中保存 N 个元素；
3. 代码实现：
    ```TS
    class MaxQueue {
      queue: number[]
      max_queue: number[]

      constructor() {
        this.queue = [];
        this.max_queue = [];
      }

      max_value(): number {
        if (!this.queue.length) return -1;
        return this.max_queue[0];
      }

      push_back(value: number): void {
        this.queue.push(value);
        while (this.max_queue.length && this.max_queue[this.max_queue.length - 1] < value) {
          this.max_queue.pop();
        }
        this.max_queue.push(value);
      }

      pop_front(): number {
        if (!this.queue.length) return -1;
        let front = this.queue.shift()
        if (front === this.max_queue[0]) {
          this.max_queue.shift();
        }
        return front;
      }
    }
    ```
    ```JS
    var MaxQueue = function () {
      this.queue = [];
      this.max_queue = [];
    };

    MaxQueue.prototype.max_value = function () {
      if (!this.queue.length) return -1;
      return this.max_queue[0];
    };

    MaxQueue.prototype.push_back = function (value) {
      this.queue.push(value);
      while (this.max_queue.length && this.max_queue[this.max_queue.length - 1] < value) {
        this.max_queue.pop();
      }
      this.max_queue.push(value);
    };

    MaxQueue.prototype.pop_front = function () {
      if (!this.queue.length) return -1;
      let front = this.queue.shift()
      if (front === this.max_queue[0]) {
        this.max_queue.shift();
      }
      return front;
    };
    ```


## [滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
### 双端队列
1. 解题思路：
    - 回忆 「包含 min 函数的栈」 ，其使用 单调栈 实现了随意入栈、出栈情况下的 O(1) 时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素”；
      - 窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列 deque；
      - deque 内仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 nums[i - 1]，需将 deque 内的对应元素一起删除；
      - deque 内的元素 非严格递减 ⇒ 每轮窗口滑动添加了元素 nums[j + 1]，需将 deque 内所有 < nums[j + 1]的元素删除；
    - 算法流程：
      - 初始化： 双端队列 deque ，结果列表 res ，数组长度 n ；
      - 滑动窗口： 左边界范围 i∈[1 - k, n - k]，右边界范围 j∈[0, n - 1]；
        - 若 i > 0 且 队首元素 deque[0] = 被删除元素 nums[i - 1]：则队首元素出队；
        - 删除 deque 内所有 < nums[j] 的元素，以保持 deque 递减；
        - 将 nums[j] 添加至 deque 尾部；
        - 若已形成窗口（即 i ≥0 ）：将窗口最大值（即队首元素 deque[0]）添加至列表 res；
      - 返回值： 返回结果列表 res；
2. 复杂度：
    - 时间复杂度 O(n)： 其中 n 为数组 nums 长度；线性遍历 nums 占用 O(n)；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2n)；
    - 空间复杂度 O(k)： 双端队列 deque 中最多同时存储 k 个元素（即窗口大小）；
3. 代码实现：
    ```JS
    /**
      * @param {number[]} nums 传入数组
      * @param {number} k 滑动窗口宽度
      * @return {number[]} 
      */
    var maxSlidingWindow = function (nums, k) {
      if (k <= 1) {
        return nums
      }

      const result = []
      const deque = []
      // 1 将窗口第一个位置的数据添加到 deque 中，保持递减（第一次取 k 个进行比较）
      deque.push(nums[0])
      let i = 1
      for (; i < k; i++) {
        // - 存在数据
        // - 当前数据大于队尾值
        //   - 出队，再重复比较
        while (deque.length && nums[i] > deque[deque.length - 1]) {
          deque.pop()
        }
        deque.push(nums[i])
      }
      // 将第一个位置的最大值添加到 result
      result.push(deque[0])


      // 2 遍历后续的数据（每次后移一位进行比较）
      const len = nums.length
      for (; i < len; i++) {
        // 同上进行比较
        while (deque.length && nums[i] > deque[deque.length - 1]) {
          deque.pop()
        }
        deque.push(nums[i])
        // 检测当前最大值是否位于窗口外（是否在 k 的范围内）
        if (deque[0] === nums[i - k]) {
          deque.shift()
        }
        // 添加最大值到 result
        result.push(deque[0])
      }
      return result
    };
    ```

### 单调队列
1. 解题思路：
    - 维护一个单调递减的队列 deque 和一个结果数组 res；
    - 当没形成窗口之前，deque 为空则直接入队，不为空要判断队尾的元素和新增的元素的大小，维护 deque 的长度等于 k；
      - 队尾的元素 < 新增元素，删掉队尾元素直到队尾元素小于新增的元素位置（维护单调递减队列）；
      - 队尾的元素 > 新增元素，直接入队；
    - 形成窗口之后，向 res 放入 deque 的队首元素（队首元素为窗口的最大值），不断维护 deque，若 deque 的队首元素等于窗口的左边界值，说明下一次滑动窗口 deuqe 的队首不在窗口内，则 deque 队首出队；
    - 滑动窗口滑到最后，返回 res；
2. 复杂度：
    - 时间复杂度：O(n) ： 其中 n 为数组 nums 长度；线性遍历 nums 占用 O(n)；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2n)；
    - 空间复杂度：O(k) ： 双端队列 deque 中最多同时存储 k 个元素（即窗口大小）；
3. 代码实现：
    ```TS
    function maxSlidingWindow(nums: number[], k: number): number[] {
      if (k === 1) return nums;

      let deQueue = [];
      let res = [];

      for (let right = 0; right < nums.length; right++) {
        let num = nums[right];
        while (deQueue.length && deQueue[deQueue.length - 1] < num) {
            deQueue.pop();
        }
        deQueue.push(nums[right]);

        let left = right - k + 1;
        if (left >= 0) {
          res.push(deQueue[0]);
          // 滑动过程中，如果序列中的最大元素即退出窗口，则移除队列头部元素
          if (nums[left] === deQueue[0]) {
            deQueue.shift();
          }
        }
      }
      return res;
    };
    ```


## [颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)
1. 解题思路：
    <img src="颠倒字符串中的单词.jpg" width="600px" height="auto" class="lazy-load" title="颠倒字符串中的单词"/>

    - 先去掉字符串两端的空格；
    - 沿着字符串一个一个单词处理；
    - 然后将单词压入队列的头部，再将队列转成字符串即可；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 为输入字符串的长度；
    - 空间复杂度：O(n)，双端队列存储单词需要 O(n) 的空间；
3. 代码实现：
    ```JS
    var reverseWords = function (s) {
      // 左右指针
      let left = 0
      let right = s.length - 1

      // 左进右出的队列
      let queue = []
      // 临时的 word，当单词是完整的时候放入队列中
      let word = ''

      // 去掉左右两侧的空格
      while (s.charAt(left) === ' ') {
        left++
      }
      while (s.charAt(right) === ' ') {
        right--
      }

      // 迭代
      while (left <= right) {
        let ch = s.charAt(left)
        if (ch == ' ' && word) {
          // 如果 ch 是空格，word 是一个单词，则把单词放入队列，并清空 word
          queue.unshift(word)
          word = ''
        } else if (ch !== ' ') {
          // 如果 ch 不是空格，说明这个单词还没有拼装完整
          word += ch
        }
        left++
      }

      // 由于两侧的空格已经被去掉了，最后一个单词不能进入 if 代码块中，则手动将 word 放入队列中
      queue.unshift(word)
      return queue.join(' ')
    };
    ```


## [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)
### 双队列实现
1. 解题思路：
    - 一个队列为主队列 queue1，一个为辅助队列 queue2；
    - 当入栈操作时，直接将值 push 到 queue1 里面；
    - 当出栈操作时，操作 queue1：
      - 如果 queue1 为空，则交换 queue1 和 queue2 的值，然后把 queue1 里面的值的个数只留下一个，其他全部shift 出队，然后 push 到 queue2 里面；
      - 如果 queue1 不为空，则把 queue1 里面的值的个数只留下一个，其他全部shift 出队，然后 push 到 queue2 里面；
2. 图解：
    <img src="用队列实现栈（双队列实现）.jpg" width="600px" height="auto" class="lazy-load" title="用队列实现栈（双队列实现）"/>
3. 复杂度：
    - 时间复杂度：入栈操作 O(n)，其余操作都是 O(1)；
    - 空间复杂度：O(n)，其中 n 是栈内的元素个数，需要使用两个队列存储栈内的元素；
4. 代码实现：
    ```JS
    var MyStack = function () {
      // 队列操作： 后进push 前出shift
      this.queue1 = []
      this.queue2 = []
    };

    MyStack.prototype.push = function (x) {
      this.queue1.push(x)
    };

    MyStack.prototype.pop = function () {
      // 减少两个队列交换的次数， 只有当queue1为空时，交换两个队列
      if (!this.queue1.length) {
        [this.queue1, this.queue2] = [this.queue2, this.queue1]
      }
      //当队列1的元素数量大于1的时候不断将元素push进备份队列
      while (this.queue1.length > 1) {
        this.queue2.push(this.queue1.shift())
      }
      //最后将队列1最后一个元素出队
      return this.queue1.shift()
    };

    MyStack.prototype.top = function () {
      const x = this.pop()
      this.queue1.push(x)
      return x
    };

    MyStack.prototype.empty = function () {
      return !this.queue1.length && !this.queue2.length
    };
    ```

### 单队列实现
1. 解题思路：
    - 入栈操作时，首先获得入栈前的元素个数 len，然后将新元素 push 入队；
    - 再将队列中的前 len 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列；
    - 此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底；
2. 图解：
    <img src="用队列实现栈（单队列实现）.jpg" width="600px" height="auto" class="lazy-load" title="用队列实现栈（单队列实现）"/>
3. 复杂度：
    - 时间复杂度：入栈操作 O(n)，其余操作都是 O(1)；
    - 空间复杂度：O(n)，其中 n 是栈内的元素个数，需要使用两个队列存储栈内的元素；
4. 代码实现：
    ```JS
    var MyStack = function () {
      this.queue = [];
    };

    MyStack.prototype.push = function (x) {
      let len = this.queue.length;
      this.queue.push(x);

      while (len--) {
        this.queue.push(this.queue.shift());
      }
    };

    MyStack.prototype.pop = function () {
      return this.queue.shift();
    };

    MyStack.prototype.top = function () {
      let top = this.pop();
      this.push(top);
      return top;
    };

    MyStack.prototype.empty = function () {
      return this.queue.length === 0
    };
    ```
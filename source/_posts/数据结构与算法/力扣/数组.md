---
title: 数组
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 数组
abbrlink: 340249a9
date: 2022-06-20 11:24:49
---

## [合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)
1. 解题思路：
    - 倒序遍历数组 nums1、nums2，将最大值放到 nums1 的最后面；
    - nums1 的后半部分是空的，可以直接覆盖而不会影响结果；
2. 复杂度：
    - 时间复杂度：O(m+n)，指针移动单调递减，最多移动 m+n 次，因此时间复杂度为O(m+n)；
    - 空间复杂度：O(1)，直接对数组 nums1原地修改，不需要额外空间；
3. 代码实现：
    ```JS
    var merge = function (nums1, m, nums2, n) {
      // nums1 最后一个元素的索引
      let i = m - 1;
      // nums2 最后一个元素的索引
      let j = n - 1;
      // nums1 数组最后位置的索引
      let end = m + n - 1;
      while (j >= 0) {
        // if (i >= 0 && nums1[i] > nums2[j]) {
        //   nums1[end--] = nums1[i--];
        // } else {
        //   nums1[end--] = nums2[j--];
        // }
        nums1[end--] = (i >= 0 && nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];
      }
    }
    ```

## [杨辉三角](https://leetcode.cn/problems/pascals-triangle/)
1. 解题思路：当前 inx 索引元素的值为，上一行 inx 和上一行 inx-1 的和；
    <img src="杨辉三角.jpg" width="600px" height="auto" class="lazy-load" title="杨辉三角"/>
2. 复杂度：
    - 时间复杂度：O(numRows2)；
    - 空间复杂度：O(1)，不考虑返回值的空间占用；
3. 代码实现：
    ```JS
    var generate = function (numRows) {
      const ret = [];

      for (let i = 0; i < numRows; i++) {
        // 每行元素数量为 索引+1
        const row = new Array(i + 1).fill(1);
        for (let j = 1; j < row.length - 1; j++) {
          row[j] = ret[i - 1][j - 1] + ret[i - 1][j];
        }
        ret.push(row);
      }

      return ret;
    };
    ```

## [矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)
### 使用标记数组
1. 解题思路：
    - 定义两个标记数组，分别记录每一行和每一列是否有零出现；
      - 遍历该二维数组一次，如果某个元素为 0；
      - 那么就将该元素所在的行和列所对应标记数组的位置置为 true；
    - 最后再次遍历该数组，用标记数组更新原数组即可；
2. 复杂度：
    - 时间复杂度：O(mn)，其中 m 是矩阵的行数，n 是矩阵的列数；
    - 空间复杂度：O(m+n)，其中 m 是矩阵的行数，n 是矩阵的列数，分别记录每一行或每一列是否有零出现；
3. 代码实现：
    ```JS
    var setZeroes = function (matrix) {
      const m = matrix.length,
        n = matrix[0].length;

      // 记录 行、列 为 0 的位置
      const row = new Array(m).fill(false);
      const col = new Array(n).fill(false);

      // 记录 0 的位置，更新到 row、col 数组中
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (matrix[i][j] === 0) {
            row[i] = col[j] = true;
          }
        }
      }
      
      // 根据 row、col 标记的位置，更新原数组
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (row[i] || col[j]) {
            matrix[i][j] = 0;
          }
        }
      }
    };
    ```

### 使用两个标记变量
1. 解题思路：
    - 用矩阵的第一行和第一列作为两个标记数组，以达到 O(1) 的额外空间；
    - 但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0，因此需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0；
    - 根据标记更新矩阵；
    - 最后使用两个标记变量更新第一行与第一列即可；
2. 复杂度：
    - 时间复杂度：O(mn)，其中 m 是矩阵的行数，n 是矩阵的列数；
    - 空间复杂度：O(1)，只需要常数空间存储若干变量；
3. 代码实现：
    ```JS
    var setZeroes = function (matrix) {
      const m = matrix.length,
        n = matrix[0].length;

      // 标记 第一行、第一列是否有 0
      let flagCol0 = false,
        flagRow0 = false;

      // 遍历第一行，是否有 0
      for (let i = 0; i < m; i++) {
        if (matrix[i][0] === 0) {
          flagCol0 = true;
        }
      }
      // 遍历第一列，是否有 0
      for (let j = 0; j < n; j++) {
        if (matrix[0][j] === 0) {
          flagRow0 = true;
        }
      }

      // 标记：遇到 0，则将 第一行、第一列 对应索引都置 0
      for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
          if (matrix[i][j] === 0) {
            matrix[i][0] = matrix[0][j] = 0;
          }
        }
      }

      // 根据标记 0的位置，覆盖数组
      for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
          if (matrix[i][0] === 0 || matrix[0][j] === 0) {
            matrix[i][j] = 0;
          }
        }
      }

      // 如果第一列、第一行原来有 0，则将第一行、第一列全部置 0
      if (flagCol0) {
        for (let i = 0; i < m; i++) {
          matrix[i][0] = 0;
        }
      }
      if (flagRow0) {
        for (let j = 0; j < n; j++) {
          matrix[0][j] = 0;
        }
      }
    };
    ```

## [矩阵对角线元素的和](https://leetcode.cn/problems/matrix-diagonal-sum/)
1. 解题思路：
    - 逐行遍历，记当前的行号为 i，对于一行把 (i, i) 位置和 (i, n - i - 1) 加入答案；
    - 这样如果 n 是奇数的话，最中间的格子会被加入两次，所以 n 为奇数的时候，需要减掉矩阵最中心的那个值；
    - n & 1 判断奇偶数（奇数 2 进制最后一位为 1，偶数 2 进制最后一位为 0）；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是矩阵 mat 的边长；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```JS
    var diagonalSum = function (mat) {
      const n = mat.length, mid = Math.floor(n / 2);
          
      let sum = 0;
      for (let i = 0; i < n; ++i) {
        sum += mat[i][i] + mat[i][n - 1 - i];
      }

      return sum - mat[mid][mid] * (n & 1);
    };
    ```


## [重塑矩阵](https://leetcode.cn/problems/reshape-the-matrix/)
### 解法一
1. 解题思路：
    - 把二维数组变成一位数组；
    - 然后 2 层循环赋值；
2. 复杂度：
    - 时间复杂度：O(rc)；
    - 空间复杂度：O(1)，这里的空间复杂度不包含返回的重塑矩阵需要的空间；
3. 代码实现：
    ```JS
    const matrixReshape = (mat, r, c) => {
      const newMat = [];
      // 将二维数组转化为一维数组
      for (let i = 0; i < mat.length; i++) {
        newMat.push(...mat[i]);
      }

      // 判断能否重塑成功
      if (r * c !== newMat.length) return mat;

      // 一共有r行
      for (let i = 0; i < r; i++) {
        const item = [];
        // 每行c个
        for (let j = 0; j < c; j++) {
          // 将c个元素从头部拿出，并放入暂存的item数组
          item.push(newMat.shift());
        }
        // 当前行收集完毕，推入新数组的尾部
        newMat.push(item);
      }

      return newMat;
    };
    ```
### 解法二（优化）
1. 解题思路：
    - 行数：i/每组里面的个数；
    - 每行的元素序号：i%每组里面的个数；
2. 复杂度：
    - 时间复杂度：O(rc)；
    - 空间复杂度：O(1)，这里的空间复杂度不包含返回的重塑矩阵需要的空间；
3. 代码实现：
    ```JS
    var matrixReshape = function (nums, r, c) {
      const row = nums.length;
      const col = nums[0].length;

      // 判断能否重塑成功
      if (row * col != r * c) return nums;

      // 生成一个 row*col 的二维数组，以 0 填充
      const ans = new Array(r).fill(0).map(() => new Array(c).fill(0));

      for (let i = 0; i < row * col; ++i) {
        ans[Math.floor(i / c)][i % c] = nums[Math.floor(i / col)][i % col];
      }

      return ans;
    };
    ```


## [整数反转](https://leetcode.cn/problems/reverse-integer/)
1. 解题思路：
    - 对 x 不断对 10 取余，然后除 10，直到为 0 即可；
    - 每次计算出新的 result 前要注意判定边界条件，不满足就提前返回了；
    - 最后在上面的过程中，不断对 result 先乘10后，再加 x 跟 10 的余数；
2. 复杂度：
    - 时间复杂度：O(log∣x∣)，翻转的次数即  x  十进制的位数；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function reverse(x: number): number {
      let res = 0;

      // x 不断左移，最后一定是 0
      while (x) {
        //每次取末尾数字
        let tmp = x % 10;

        //判断是否 大于 最大32位整数（最大32位数字为 2147483647）
        if (res > 214748364 || (res === 214748364 && tmp > 7)) {
          return 0;
        }
        //判断是否 小于 最小32位整数（最小32位数字为 -2147483648）
        if (res < -214748364 || (res === -214748364 && tmp < -8)) {
          return 0;
        }

        res = res * 10 + tmp;
        x = ~~(x / 10);
      }

      return res;
    }
    ```


## [移除元素](https://leetcode.cn/problems/remove-element/)
1. 解题思路：
    - 定义两个指针，都指向第一个位置，一个 i 用来迭代数组，另一个 k 用于记录不为 val 的位置；
    - 迭代数组，只要当前元素不等于 val，则为当前 k 位置赋值为当前元素；
    - 这样所有不为 val 的元素都被放到了数组的最前面；
2. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```JS
    var removeElement = function (nums, val) {
      let k = 0;

      for (let i = 0; i < nums.length; i++) {
        if (nums[i] != val) {
          nums[k++] = nums[i];
        }
      }

      return k;
    };
    ```

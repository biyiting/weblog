---
title: 字符串
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 字符串
abbrlink: fc81fbfd
date: 2022-06-29 11:24:49
---

## [验证外星语词典](https://leetcode.cn/problems/verifying-an-alien-dictionary/)
1. 解题思路：
    - 先用 hash 记录 order 的字典顺序；
    - 再两两比较 words 数组里面的字符串是不是满足字典序；
2. 复杂度：
    - 时间复杂度：O(m\*n)，其中 m 为字符串数组的长度，n 为数组中字符串的平均长度，每个字符串需要前一个字符串进行比较，因此时间复杂度为 O(m*n)；
    - 空间复杂度：O(C)，其中 C 表示字母表的长度，需要存储字母表 order 每个字符的字典序索引，题目中给定的字母表的长度为 C = 26；
3. 代码实现：
    ```JS
    var isAlienSorted = function (words, order) {
      let map = {}
      const len = order.length
      for (let i = 0; i < len; i++) {
        map[order[i]] = i
      }

      function isAfterWordBigger(w1, w2) {
        const len1 = w1.length
        const len2 = w2.length
        for (let i = 0; i < len1 && i < len2; i++) {
          if (map[w1[i]] < map[w2[i]]) {
            return true
          } else if (map[w1[i]] > map[w2[i]]) {
            return false
          }
        }
        // 遍历退出后，前面字符的字典序完全相同，不分胜负，则更长的一方字典序更大
        return len2 >= len1 ? true : false
      }

      // 两两判断 words 数组里面的元素，是不是按字典序排列的
      for (let i = 0; i < words.length - 1; i++) {
        if (!isAfterWordBigger(words[i], words[i + 1])) {
          return false
        }
      }
      return true
    };
    ```


## [左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)
### 取余
1. 解题思路：
    - 取余比较巧妙，从 n 开始，到 len + n；
    - 对 len 取模，当 i <= len时，整个遍历过程拿到的是n -> len 的字符，但 i > len 时，i % len 的结果等于0 到 n 的下标；
2. 复杂度：
    - 时间复杂度： O(n)；
    - 空间复杂度： O(n)；
3. 代码实现：
    ```TS
    function reverseLeftWords(s: string, n: number): string {
      let result: string = "";

      for (let i = n; i < n + s.length; i++) {
        result += s[i % s.length];
      }

      return result;
    };
    ```

### 队列
1. 解题思路：
    - 把字符串转成数组，当旋转 2 次，那么执行 2 次出队再入队，就能得到旋转后的结果；
2. 复杂度：
    - 时间复杂度： O(n)；
    - 空间复杂度： O(n)；
3. 代码实现：
    ```TS
    function reverseLeftWords(s: string, n: number): string {
      let res = s.split('');

      while (n-- > 0) {
        res.push(res.shift());
      }

      return res.join('');
    };
    ```


## [字符串转换整数(atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)
### 字符串遍历
1. 图解
    <img src="字符串转换整数(字符串遍历)1.jpg" width="600px" height="auto" class="lazy-load" title="字符串转换整数(字符串遍历)"/>
    <img src="字符串转换整数(字符串遍历)2.jpg" width="600px" height="auto" class="lazy-load" title="字符串转换整数(字符串遍历)"/>
2. 代码实现
    ```JS
    var strToInt = function (s) {
      let flag = 1; // 符号位默认为正数
      let inx = 0; // 字符索引
      let res = 0;
      let bndry = 214748364;

      // 去掉字符前面的空格
      while (s[inx] === ' ') {
        inx++;
      }

      // 获取符号位
      if (inx < s.length && s[inx] === '+') {
        inx++;
      } else if (inx < s.length && s[inx] === '-') {
        flag = -1;
        inx++;
      }

      while (inx < s.length && s[inx] <= '9' && s[inx] >= '0') {
        // 字符转数字： 此数字的 ASCII 码 与 0 的 ASCII 码相减即可
        let digit = s[inx++] - '0';

        if (res > bndry || res === bndry && digit > 7) return flag == 1 ? 2147483647 : -2147483648;

        res = res * 10 + digit;
      }

      return res * flag;
    };
    ```
### 正则
1. 代码实现：
    ```JS
    var myAtoi = function (str) {
      //利用正则
      // [ '1213342232', index: 0, input: '1213342232', groups: undefined ]
      let result = str.trim().match(/^[-|+]{0,1}[0-9]+/)

      if (result != null) {
        if (result[0] > (Math.pow(2, 31) - 1)) {
          return Math.pow(2, 31) - 1
        }
        if (result[0] < Math.pow(-2, 31)) {
          return Math.pow(-2, 31)
        }
        return result[0]
      }

      return 0
    };
    ```

### parseInt API
1. 代码实现：
    ```JS
    var myAtoi = function (str) {
      const number = parseInt(str, 10);

      if (isNaN(number)) {
        return 0;
      } else if (number < Math.pow(-2, 31) || number > Math.pow(2, 31) - 1) {
        return number < Math.pow(-2, 31) ? Math.pow(-2, 31) : Math.pow(2, 31) - 1;
      } else {
        return number;
      }
    };
    ```


## [表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)
1. 解题思路：
    - 去掉字符串的空格，并初始化 数字、小数点、e 标识符；
    - 小数点只可以出现在 e 之前，且只能出现一次，.num  num.num num.都是被允许的；
    - 判定为 e，之前没出现过 e，之前出现过数字了，e 后面必须出现数字；
    - 判定为 +/- 符号，只能出现在第一位或者紧接 e 后面；
2. 复杂度：
    - 时间复杂度： O(N)，其中 N 为字符串 s 的长度；
    - 空间复杂度： O(1)，使用常数大小的额外空间；
3. 代码实现：
    ```TS
    function isNumber(s: string): boolean {
      if (s == null || s.length == 0) return false;

      //去掉首位空格
      s = s.trim();

      //是否出现数字
      let numFlag: boolean = false;
      //是否出现小数点
      let dotFlag: boolean = false;
      // 是否出现 e
      let eFlag: boolean = false;

      for (let i = 0; i < s.length; i++) {
        //判定为数字，则标记numFlag
        if (s[i] >= '0' && s[i] <= '9') {
          numFlag = true;
          //小数点只可以出现再e之前，且只能出现一次.num  num.num num.都是被允许的
        } else if (s[i] == '.' && !dotFlag && !eFlag) {
          dotFlag = true;
          //判定为e，之前没出现过e，之前出现过数字了
        } else if ((s[i] == 'e' || s[i] == 'E') && !eFlag && numFlag) {
          eFlag = true;
          //避免e以后没有出现数字
          numFlag = false;
        } else if ((s[i] == '+' || s[i] == '-') && (i == 0 || s[i - 1] == 'e' || s[i - 1] == 'E')) {
          //判定为+-符号，只能出现在第一位或者紧接e后面
          continue;
        } else {
          //其他情况，都是非法的
          return false;
        }
      }

      //是否出现了数字 
      return numFlag;
    };
    ```

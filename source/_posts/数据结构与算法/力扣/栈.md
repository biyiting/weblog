---
title: 栈
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 栈
abbrlink: 1f4ac2fb
date: 2022-07-05 11:24:49
---

## 栈基础
1. 栈的定义：
    - 栈是一个后进先出（Last In Fist Out, LIFO）的线性表，要求只在栈顶进行删除和插入操作；
    - 所谓的栈，其实就是一个特殊的线性表（顺序表、链表），但是它在操作上有一些特殊的要求和限制：
      - 栈的元素必须“后进先出”；
      - 栈的操作只能在这个线性表的栈顶进行；
      - 对于栈来说，这个表尾称为栈的栈顶（top），相应的表头称为栈底（bottom）；
2. 栈的插入和删除操作：
    - 插入操作（Push）：叫做进栈，也称为压栈，入栈；
    - 删除操作（Pop）：叫做出栈，也称为弹栈；
3. 栈的存储结构
    - 「顺序」存储结构
      <img src="「顺序」存储结构.jpg" width="300px" height="auto" class="lazy-load" title="「顺序」存储结构"/>
    - 「链式」存储结构
      <img src="「链式」存储结构.jpg" width="300px" height="auto" class="lazy-load" title="「顺序」存储结构"/>

## 栈的实现
1. 实现以下功能：
    - push()： 入栈；
    - pop()： 出栈；
    - top()： 获取栈顶值；
    - size()： 获取栈的元素个数；
    - clear()： 清空栈；
2. 示例代码：
    ```JS
    class Stack {
      constructor() {
        // 存储栈的数据
        this.data = {}
        // 记录栈的数据个数（相当于数组的 length）
        this.count = 0
      }
    
      // push() 入栈方法
      push(item) {
        // 方式1：数组方法 push 添加（不推荐）
        // this.data.push(item)
    
        // 方式2：利用数组长度（不推荐）
        // this.data[this.data.length] = item
    
        // 方式3：计数方式（建议使用）
        this.data[this.count] = item
        // 入栈后，count 自增
        this.count++
      }
    
      // pop() 出栈方法
      pop() {
        // 出栈的前提是栈中存在元素，应先行检测
        if (this.isEmpty()) {
          console.log('栈为空！')
          return
        }
        // 移除栈顶数据
        // 方式1：数组方法 pop 移除
        // return this.data.pop()
    
        // 方式2：计数方式
        const temp = this.data[this.count - 1]
        delete this.data[--this.count]
        return temp
      }
    
      // isEmpty() 检测栈是否为空
      isEmpty() {
        return this.count === 0
      }
    
      // top() 用于获取栈顶值
      top() {
        if (this.isEmpty()) {
          console.log('栈为空！')
          return
        }
        return this.data[this.count - 1]
      }
    
      // size() 获取元素个数
      size() {
        return this.count
      }
    
      // clear() 清空栈
      clear() {
        this.data = {}
        this.count = 0
      }
    }
    
    const s = new Stack()
    s.push('a')
    s.push('b')
    s.push('c')
    ```

## [有效的括号](https://leetcode.cn/problems/valid-parentheses/)
1. 解题思路：
    - 如果是左括号，则直接入栈；
    - 如果是右括号，则将其与栈顶元素进行匹配；如果此时栈为空，则说明右括号多，false；如果不匹配，false；如果匹配，则出栈；
    - 最后检查栈是否为空，若不为空，说明左括号多，false；
2. 复杂度：
    - 时间复杂度 O(N)：正确的括号组合需要遍历 1 遍 ；
    - 空间复杂度 O(N)：哈希表和栈使用线性的空间大小；
3. 代码实现：
    ```JS
    var isValid = function (s) {
      let stack = []
      let obj = {
        '(': ')',
        '[': ']',
        '{': '}'
      }

      for (let i = 0; i < s.length; i++) {
        const ele = s[i]
        if (ele in obj) {
          //正括号的场景：入栈
          stack.push(ele)
        } else {
          //反括号的场景：出栈
          if (ele != obj[stack.pop()]) {
            return false //不匹配
          }
        }
      }

      // 括号遍历结束，栈中还有数据则说明正括号过多，错误
      return !stack.length
    };
    ```


## [简化路径](https://leetcode.cn/problems/simplify-path/)
1. 解题思路：
    - 路径分隔以后的几种情况：
      - 空字符串，例如当出现多个连续的 /，就会分割出空字符串；
      - 一个点 .；
      - 两个点 ..；
      - 只包含英文字母、数字或 _ 的目录名；
    - 包含英文字母、数字或 _ 的目录名的时候，入栈，两个点的时候出栈；
    - 最后遍历栈中的目录名，以 / 拼接；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是字符串 path 的长度；
    - 空间复杂度：O(n)，需要 O(n) 的空间存储 names 中的所有字符串；
3. 代码实现：
    ```JS
    var simplifyPath = function (path) {
      // "/a/./b/../../c/"
      let stack = []
      let paths = path.split('/')

      for (let i = 0; i < paths.length; i++) {
        const p = paths[i]
        if (p == '..') {
          stack.pop()
        } else if (p && p !== '.') {
          // p 不等于 . 和 '' 的情况
          stack.push(p)
        }
      }

      // join 方法用于把数组中的所有元素放入一个字符串，通过指定的分隔符进行分隔的
      return '/' + stack.join('/')
    };
    ```


## [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
1. 解题思路
    - 用 stack1、stack2 两个栈实现队列，队列是先进先出，栈是后进先出；
    - push 方法将数据放到 stack1 中，stack1 用来存储数据；
    - pop 方法将 stack2 中的栈顶数据弹出去，当 stack2 空的时候，将 stack1 pop出来，放入 stack2 中，这样就实现了队列的效果；
2. 图解
    <img src="用栈实现队列.jpg" width="600px" height="auto" class="lazy-load" title="用栈实现队列"/>
3. 复杂度：
    - 时间复杂度：O(n)；
      - 对于除了新元素之外的所有元素，它们都会被压入两次，弹出两次，新元素只被压入一次，弹出一次；
      - 这个过程产生了 4n + 2 次操作，其中 n 是队列的大小；
      - 由于 压入 操作和 弹出 操作的时间复杂度为 O(1)， 所以时间复杂度为 O(n)；
    - 空间复杂度：O(n)，需要额外的内存来存储队列中的元素；
4. 代码实现：
    ```TS
    class MyQueue {
      stack1: Array<number>
      stack2: Array<number>

      constructor() {
        // 用来入栈
        this.stack1 = [];
        // 用来出栈
        this.stack2 = [];
      }

      push(x: number): void {
        this.stack1.push(x);
      }

      pop(): number {
        // 只要 stack2 有值，就直接 return
        if (this.stack2.length > 0) {
          return this.stack2.pop();
        }
        // 当 stack2为空的时候，将 stack1 的值放到 stack2 中
        while (this.stack1.length > 0) {
          this.stack2.push(this.stack1.pop());
        }
        return this.stack2.pop();
      }

      peek(): number {
        let tmp = this.pop();
        this.stack2.push(tmp);
        return tmp;
      }

      empty(): boolean {
        return this.stack1.length === 0 && this.stack2.length === 0;
      }
    }
    ```
    ```JS
    var MyQueue = function () {
      // 用来入栈
      this.stack1 = [];
      // 用来出栈
      this.stack2 = [];
    };

    MyQueue.prototype.push = function (x) {
      this.stack1.push(x);
    };

    MyQueue.prototype.pop = function () {
      // 只要 stack2 有值，就直接 return
      if (this.stack2.length > 0) {
        return this.stack2.pop();
      }

      // 当 stack2为空的时候，将 stack1 的值放到 stack2 中
      while (this.stack1.length > 0) {
        this.stack2.push(this.stack1.pop());
      }

      return this.stack2.pop();
    };

    MyQueue.prototype.peek = function () {
      let tmp = this.pop();
      this.stack2.push(tmp);
      return tmp;
    };

    MyQueue.prototype.empty = function () {
      return this.stack1.length === 0 && this.stack2.length === 0;
    };
    ```

## [逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)
1. 解题思路：
    - 如果遇到操作数，则将操作数入栈；
    - 如果遇到运算符，则将两个操作数出栈，其中先出栈的是右操作数，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是数组 tokens 的长度，需要遍历数组 tokens 一次，计算逆波兰表达式的值；
    - 空间复杂度：O(n)，其中 n 是数组 tokens 的长度，使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度；
3. 代码实现：
    ```JS
    var evalRPN = function (tokens) {
      let calc = {
        '+': (a, b) => a + b,
        '-': (a, b) => b - a,
        '*': (a, b) => a * b,
        '/': (a, b) => (b / a) | 0, // | 0 直接去掉正负数小数点后面的
      }

      let stack = []

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i]
        if (t in calc) {
          // 增删改查
          stack.push(calc[t](stack.pop(), stack.pop()))
        } else {
          // 数组
          stack.push(Number(t))
        }
      }

      return stack.pop()
    };
    ```

## [删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)
1. 解题思路：
    - 迭代字符串 s，并维护一个栈；
    - 如果当前的字符和栈中的最后一个字符相同，则出栈栈中的最后一个字符，否则入栈当前字符；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是字符串的长度，只需要遍历该字符串一次；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```JS
    var removeDuplicates = function (s) {
      let stack = []

      for (const x of s) {
        let len = stack.length
        if (len && stack[len - 1] == x) {
          stack.pop()
          continue
        }
        stack.push(x)
      }

      return stack.join("")
    };
    ```


## [删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/)
### 栈
1. 解题思路：
    - 当遇到 '(' 入栈，当遇到 ')' 出栈，当 stack 为空，说明找到了原语；
    - 当 stack 不为空的时候，将当前元素放到结果中；
    - 由于栈底和栈顶是原语的左右括号，先判断右括号，会跳过将栈底放入结果中，此步骤为优化；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是输入 s 的长度，仅需遍历 s 一次；
    - 空间复杂度：O(n)，其中 n 是输入 s 的长度，需要使用栈，长度最大为 O(n)；
3. 代码实现：
    ```TS
    function removeOuterParentheses(s: string): string {
      let stack: Array<string> = [];
      let res: string = '';

      for (let i = 0; i < s.length; i++) {
        if (s[i] === ')') stack.pop();

        if (stack.length) res += s[i];

        if (s[i] === '(') stack.push(s[i]);
      }

      return res;
    };
    ```

### 双指针
1. 解题思路：
    - 新建计数双指针，left 记录 '(' 的个数，right 记录 ')' 的个数，当 left === right 时，说明找到了原语；
    - 默认 last = 0，记录原语的下一个位置；
    - 将原语 [last + 1, j - 1) 加入答案；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是输入 s 的长度，仅需遍历 s 一次；
    - 空间复杂度：O(n)，其中 n 是输入 s 的长度，需要使用栈，长度最大为 O(n)；
3. 代码实现：
    ```JS
    var removeOuterParentheses = function (s) {
      let left = 0;
      let right = 0;
      let last = 0;
      let res = '';

      for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') left++;
        if (s[i] === ')') right++;

        if (left === right) {
          res += s.slice(last + 1, i).toString();
          last = i + 1;
        }
      }

      return res;
    };
    ```

### 单指针
1. 解题思路：
    - 新建计数单指针，遇到 '(' 的时候 count++，遇到 ')' 的时候 count--，当 count===0 时，说明找到了原语；
    - 默认 last = 0，记录原语的下一个位置；
    - 将原语 [last + 1, j - 1) 加入答案；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是输入 s 的长度，仅需遍历 s 一次；
    - 空间复杂度：O(n)，其中 n 是输入 s 的长度，需要使用栈，长度最大为 O(n)；
3. 代码实现：
    ```JS
    var removeOuterParentheses = function (s) {
      let last = 0;
      let count = 0;
      let res = '';

      for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') count++;
        if (s[i] === ')') count--;

        if (count === 0) {
          res += s.slice(last + 1, i).toString();
          last = i + 1;
        }
      }

      return res;
    };
    ```

## [包含min函数的栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)
1. 解题思路：
    - 设计一个数据结构，使得每个元素与其相应的最小值  时刻保持一一对应，因此可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值；
    - 当一个元素要入栈时，取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；
    - 当一个元素要出栈时，把辅助栈的栈顶元素也一并弹出；
    - 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中；
2. 复杂度：
    - 时间复杂度：时间复杂度均为 O(1)；
    - 空间复杂度：O(n)，其中 n 为总操作数；最坏情况下，会连续插入 n 个元素，此时两个栈占用的空间为 O(n)；
3. 代码实现：
    ```TS
    class MinStack {
      stack: Array<number>
      minStack: Array<number>

      constructor() {
        this.stack = [];
        // 在存储数据的栈外，再新建一个栈，用于存储最小值
        this.minStack = [Infinity];
      }

      push(x: number): void {
        this.stack.push(x);
        let minNum = Math.min(this.minStack[this.minStack.length - 1], x)
        this.minStack.push(minNum);
      }

      pop(): void {
        this.stack.pop();
        this.minStack.pop();
      }

      top(): number {
        return this.stack[this.stack.length - 1];
      }

      min(): number {
        return this.minStack[this.minStack.length - 1];
      }
    }
    ```
    ```JS
    var MinStack = function () {
      this.stack = [];
      // 在存储数据的栈外，再新建一个栈，用于存储最小值
      this.minStack = [Infinity];
    };

    MinStack.prototype.push = function (x) {
      this.stack.push(x);

      let minNum = Math.min(this.minStack[this.minStack.length - 1], x)
      this.minStack.push(minNum);
    };

    MinStack.prototype.pop = function () {
      this.stack.pop();
      this.minStack.pop();
    };

    MinStack.prototype.top = function () {
      return this.stack[this.stack.length - 1];
    };

    MinStack.prototype.min = function () {
      return this.minStack[this.minStack.length - 1];
    };
    ```


## [栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)
1. 解题思路：
    - 定义一个辅助栈 stack；
    - 遍历 pushed 不断将里面的元素 push 到辅助栈 stack 里面，每 push 一次就判断一下栈顶的元素是不是等于 popped 的对应索引位置的元素；
      - 如果 stack[i] === popped[i]，则 stack 栈顶元素出栈；
      - 如果 stack[i] !== popped[i]，则 stack 继续入栈；
    - 最后判断 stack 是否为空，为空说明 pushed、popped 是合法序列；
2. 图解：图来自 「k神」
    <img src="栈的压入、弹出序列1.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列2.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列3.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列4.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列5.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列6.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列7.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列8.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列9.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列10.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列11.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
    <img src="栈的压入、弹出序列12.jpg" width="600px" height="auto" class="lazy-load" title="栈的压入、弹出序列"/>
3. 复杂度：
    - 时间复杂度：O(N)，其中 N 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作；
    - 空间复杂度：O(N)，辅助栈 stack 最多同时存储 N 个元素；
4. 代码实现：
    ```TS
    function validateStackSequences(pushed: number[], popped: number[]): boolean {
      let stack = [];
      let inx = 0;

      for (let i = 0; i < pushed.length; i++) {
        stack.push(pushed[i]);
        while (stack.length && stack[stack.length - 1] == popped[inx]) {
          stack.pop();
          inx++;
        }
      }

      return stack.length === 0;
    };
    ```

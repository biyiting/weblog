---
title: 递归
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 递归
abbrlink: c6654282
date: 2022-07-10 11:24:49
---

## [汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)
1. 解题思路：
    - 若 n 为奇数，按顺时针依次摆放 A、C、B，若 n 为偶数，按顺时针依次摆放 A、B、C；
    - 按顺时针方向把最小的圆盘从现在的柱子上移动到下一根柱子；
    - 把另外两根柱子上可以移动的圆盘移动到新的柱子上；
      - 把非空柱子上的圆盘移动到空柱子上；
      - 当两根柱子都非空时，移动较小的圆盘；
    - 反复进行以上两步操作，最后就能按规定完成汉诺塔的移动；
2. 复杂度：
    - 时间复杂度：O(2^n-1)，一共需要移动的次数；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function hanota(A: number[], B: number[], C: number[]): void {
      if (A.length === 1) {
        C.push(A.pop());
        return;
      }

      let len = A.length;
      // 根据圆盘数量判断柱子的摆放顺序
      let lists = new Array();
      if ((len & 1) as number === 1) {
        // 若 n 为奇数，按顺时针依次摆放 A、C、B
        lists.push(A, B, C);
      } else {
        // 若 n 为偶数，按顺时针依次摆放 A、B、C
        lists.push(A, C, B);
      }

      // 循环两步法：（所有圆盘都移动到 C 上）
      let currInx = 0; // 当前最小圆盘所在位置
      while (C.length < len) {
        // 1.按顺时针方向把最小的圆盘从现在的柱子上移动到下一根柱子
        //  1.1 找到最小的圆盘所在柱子 curr，下一个柱子 next
        let curr = lists[currInx];
        let next = lists[(currInx + 1) % 3];
        //  1.2 最小的圆盘移动到下一根柱子
        next.push(curr.pop());

        currInx = (currInx + 1) % 3;

        // 2.把另外两根柱子上可以移动的圆盘移动到新的柱子上
        //  2.1 找到另一个柱子 prev，prev = curr.next.next（三个柱子循环）
        let prev = lists[(currInx + 1) % 3];
        //  2.2 获取两个柱子的栈顶元素做比较，空的则标记为最大值
        let move1 = prev.length === 0 ? Infinity : prev[prev.length - 1];
        let move2 = curr.length === 0 ? Infinity : curr[curr.length - 1];
        //  2.3 把非空柱子上的圆盘移动到空柱子上，当两根柱子都非空时，移动较小的圆盘
        if (move1 > move2) {
          prev.push(curr.pop());
        } else if (move2 > move1) {
          curr.push(prev.pop());
        }
      }
    };
    ```


## [斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
### 迭代+缓存
1. 图解：
    <img src="斐波那契数.jpg" width="600px" height="auto" class="lazy-load" title="斐波那契数"/>
2. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function fib(n: number): number {
      if (n < 2) return n;

      let memo = [0, 1];
      let res = 0;

      for (let i = 2; i <= n; i++) {
        res = memo[0] + memo[1];

        memo[0] = memo[1];
        memo[1] = res;
      }

      return res;
    }
    ```

### 递归+缓存
1. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(n)；
2. 代码实现：
    ```TS
    function fib(n: number): number {
      let list = [0, 1];
      return reverse(list, n);
    }

    function reverse(memo: Array<number>, n: number): number {
      if (n < 2) return n;
      if (memo[n]) return memo[n];

      memo[n] = reverse(memo, n - 1) + reverse(memo, n - 2);
      return memo[n];
    }
    ```


## [第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)
### 迭代
1. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(1)；
2. 代码实现：
    ```TS
    function tribonacci(n: number): number {
      let memo = [0, 1, 1];
      let res = 0;

      if (n < 3) return memo[n];

      for (let i = 3; i <= n; i++) {
        res = memo[0] + memo[1] + memo[2];
        memo[0] = memo[1];
        memo[1] = memo[2];
        memo[2] = res;
      }

      return res;
    }
    ```

### 递归
1. 复杂度：
    - 时间复杂度：O(n)；
    - 空间复杂度：O(n)；
2. 代码实现：
    ```TS
    function tribonacci(n: number): number {
      var list = [0, 1, 1];

      function reverse(memo, n) {
        if (n < 3) return list[n];
        if (memo[n]) return memo[n];

        memo[n] = reverse(memo, n - 1) + reverse(memo, n - 2) + reverse(memo, n - 3);
        return memo[n];
      }

      return reverse(list, n);
    }
    ```

## [Pow(x, n)](https://leetcode.cn/problems/powx-n/)
### 快速幂+递归
1. 解题思路：
    - 对于一个 x 的 n 次方： 如果 n 小于 0 ，x 的 n 次方 等于 1/x 的 -n 次方（此时 -n 为正数）；
    - 如果 n 是一个偶数：x 的 n 次方 等于 x*x 乘以 n/2 次方；
    - 如果 n 是一个奇数：x 的 n 次方 等于 x 乘以 x 的 n-1 次方；
    - 如果 n 等于 0 ，直接返回 1；
2. 图解：
    <img src="Pow(x, n)（快速幂+递归）.jpg" width="600px" height="auto" class="lazy-load" title="Pow(x, n)（快速幂+递归）"/>
3. 复杂度：
    - 时间复杂度：O(logn)，即为递归的层数；
    - 空间复杂度：O(logn)，即为递归的层数，这是由于递归的函数调用会使用栈空间；
4. 代码实现：
    ```TS
    function myPow(x: number, n: number): number {
      // n=0 直接返回 1
      if (n === 0) return 1;

      // n<0 时 x 的 n 次方等于 1 除以 x 的 -n 次方分
      if (n < 0) return 1 / myPow(x, -n);

      // n 是奇数时 x 的 n 次方 = x*x 的 n-1 次方
      if (n % 2) return x * myPow(x, n - 1);

      // n 是偶数，使用分治，一分为二，等于 x*x 的 n/2 次方
      return myPow(x * x, n / 2);
    }
    ```
### 快速幂+位运算
1. 解题思路：
    <img src="Pow(x, n)（快速幂+位运算）.jpg" width="500px" height="auto" class="lazy-load" title="Pow(x, n)（快速幂+位运算）"/>
2. 复杂度：
    - 时间复杂度：O(logn)，二分的时间复杂度为对数级别；
    - 空间复杂度：O(1)，变量占用常数大小额外空间；
3. 代码实现：
    ```TS
    function myPow(x: number, n: number): number {
      // 如果 n 小于 0 ，x 的 n 次方 等于 1/x 的 -n 次方（此时 -n 为正数）
      if (n < 0) {
        x = 1 / x;
        n = -n;
      }

      let result = 1;
      while (n) {
        // 判断 n 的二进制最后一位是 1，则将结果乘以 x
        if (n & 1) result *= x; 
        // n 是一个偶数：x 的 n 次方 等于 x*x 乘以 x 的 n/2 次方
        x *= x;
        n >>>= 1;
      }

      return result;
    };
    ```


## [特殊的二进制序列](https://leetcode.cn/problems/special-binary-string/)
1. 解题思路：
    - 将 1 看成 "("，0 看成 ")"，实际上是一道有效的括号问题，最终要让前面左括号尽可能多；
    - 第一步：将字符串拆分成一段或几段 “不可拆分的有效的括号字符串”；
    - 第二步：将每一段内部的子串（也是 “有效的括号字符串”）分别重新排列成字典序最大的字符串（解决子问题）；
    - 第三步：由于每一对相邻的段都可以交换，因此无限次交换相当于可以把各个段以任意顺序排列，找到字典序最大的排列；
2. 图解：
    <img src="特殊的二进制序列1.jpg" width="500px" height="auto" class="lazy-load" title="特殊的二进制序列"/>
    <img src="特殊的二进制序列2.jpg" width="500px" height="auto" class="lazy-load" title="特殊的二进制序列"/>
    <img src="特殊的二进制序列3.jpg" width="500px" height="auto" class="lazy-load" title="特殊的二进制序列"/>
    <img src="特殊的二进制序列4.jpg" width="500px" height="auto" class="lazy-load" title="特殊的二进制序列"/>
3. 复杂度：
    - 时间复杂度：O(n^2)；
    - 空间复杂度：O(n)，即为递归需要的栈空间以及存储递归返回的字符串需要的临时空间；
4. 代码实现：
    ```TS
    function makeLargestSpecial(s: string): string {
      // 1.结束条件
      if (s.length <= 1) return s;

      // 2.函数主功能：遍历查找子串、子串排序、子串逆序拼接成字符串
      let strList: Array<string> = [];
      let start: number = 0; // 符合规则特殊字串的起始位置
      let countOne: number = 0; // 存放 1、0 的数量差
      // 从前往后遍历查找，以 start 开头是否存在符合要求的子串
      for (let i = 0; i < s.length; i++) {
        // 计算 1、0 的数量差
        countOne += s[i] === "1" ? 1 : -1;
        // countOne === 0，表示找到第一个特殊字符
        if (countOne === 0) {
          // 对特殊字符去掉头尾的 1、0 然后递归求解字典序最大
          let result = makeLargestSpecial(s.substring(start + 1, i));
          // 在递归结果上添加头尾 1、0 放入到字符串数组中
          strList.push(`1${result}0`);
          // 记录特殊子串下标位置
          start = i + 1;
        }
      }

      // 3. 对数组中的连续子串进行冒泡排序
      strList.sort((a, b) => b.localeCompare(a));
      // 排序后的连续子串，逆序拼成字符串
      return strList.join("");
    }
    ```

## [3 的幂](https://leetcode.cn/problems/power-of-three/)
### 迭代
1. 解题思路：
    - 不断地将 n  除以 3，直到 n=1；
    - 如果此过程中  n 无法被 3 整除，就说明  n 不是  3  的幂；
2. 复杂度：
    - 时间复杂度：O(logn)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function isPowerOfThree(n: number): boolean {
      while (n !== 0 && n % 3 === 0) {
        n = Math.floor(n / 3);
      }

      return n === 1;
    };
    ```

### 判断是否为最大 3 的幂的约数
1. 解题思路：
    - 给定的 32 位有符号整数的范围内，最大的 3 的幂为 3^19 = 11622614673，只需要判断 n 是否是 3^19 的约数即可；
    - 这里需要特殊判断 n  是负数或  0  的情况；
2. 复杂度：
    - 时间复杂度：O(1)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function isPowerOfThree(n: number): boolean {
      return n > 0 && 1162261467 % n === 0;
    };
    ```


## [圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)
1. 解题思路：
    - 问题转换：
      <img src="圆圈中最后剩下的数字1.jpg" width="500px" height="auto" class="lazy-load" title="圆圈中最后剩下的数字"/>

      - 从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号；
      - 第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）；
      - 第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）；
      - 第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）；
      - 以此类推，当只剩一个人时，他的编号必定为0！（重点！）；
    - 最终活着的人编号的反推：先把被杀掉的 C 补充回来，然后右移 m 个人，发现溢出了，再把溢出的补充在最前面；
      <img src="圆圈中最后剩下的数字2.jpg" width="500px" height="auto" class="lazy-load" title="圆圈中最后剩下的数字"/>

    - 递推公式：f(8,3)=[f(7,3)+3]%8
      <img src="圆圈中最后剩下的数字3.jpg" width="500px" height="auto" class="lazy-load" title="圆圈中最后剩下的数字"/>

      - 当只有一个人时，这个人必死；
      - 当人数大于 1 时，按照下面的递推公式得到最终活着的人；
2. 复杂度：
    - 时间复杂度：O(n)，需要求解的函数值有 n 个；
    - 空间复杂度：O(n)，函数的递归深度为 n，需要使用  O(n) 的栈空间；O(1)，迭代的空间复杂度为 O(1)；
3. 代码实现：
    ```TS
    // 递归
    function lastRemaining(n: number, m: number): number {
      function travese(n, m) {
        // 若只有 1 个人的时候，这个人就是活着的人
        if (n == 1) return 0;

        // 每次循环右移
        return (travese(n - 1, m) + m) % n;
      }

      return travese(n, m);
    };
    ```
    ```TS
    // 迭代
    function lastRemaining(n: number, m: number): number {
      // 若只有 1 个人的时候，这个人就是活着的人
      let pos = 0;  
      // 需要 2 个人以上的时候，求出活着的人
      for (let i = 2; i <= n; i++) {
        // 每次循环右移
        pos = (pos + m) % i;
      }

      return pos;
    };
    ```

---
title: 位运算
categories:
  - 数据结构与算法
  - 力扣
tags:
  - 算法
  - 位运算
abbrlink: 2633a26
date: 2022-06-28 11:24:49
---

## 位运算基础
### 位运算 AND
> 当对一对数位执行位运算 AND 时，如果数位均为 1 则返回 1

|运算	|结果|
|:-----:|:----:|
|1111 & 0000|	0000|
|1111 & 0001|	0001|
|1111 & 0010|	0010|
|1111 & 0100|	0100|


### 位运算 OR
> 当对一对数位执行位运算 OR 时，如果其中一位是 1 则返回 1

|运算	|结果|
|:-----:|:----:|
|	1111 \| 0000	|1111|
|	1111 \| 0001	|1111|
|	1111 \| 0010	|1111|
|	1111 \| 0100	|1111|


### 位运算 XOR
> 当对一对数位进行位运算 XOR 时，如果数位是不同的则返回 1

|运算	|结果|
|:-----:|:----:|
|	1111 ^ 0000	|1111|
|	1111 ^ 0001	|1110|
|	1111 ^ 0010	|1101|
|	1111 ^ 0100	|1011|


### 位运算左移（<<）
> 这是零填充的左移，一个或多个零数位从右被推入（乘以2）

|运算	|结果|
|:-----:|:----:|
|	5	|101|
|	5 << 1|	1010|


### 位运算右移（>>）
> 这是保留符号的右移，最左侧的数位被从左侧推入，最右侧的数位被移出（整除2）

|运算	|结果|
|:-----:|:----:|
|	5	|101|
|	5 >> 1|	10|


### 权限认证
```JS
// 权限声明
let STYLE = 1
let CLASS = 1 << 1
let COUNT = 1 << 2

// 授权 |
let vnodeType = STYLE | CLASS

// 判断权限 &
console.log('STYLE=>' + (vnodeType & STYLE)); // 有 STYLE 权限
console.log('CLASS=>' + (vnodeType & CLASS)); // 有 CLASS 权限
console.log('COUNT=>' + (vnodeType & COUNT)); // 没有 COUNT 权限

// 删除权限 ^
vnodeType = vnodeType ^ CLASS

console.log('STYLE=>' + (vnodeType & STYLE)); // 有 STYLE 权限
console.log('CLASS=>' + (vnodeType & CLASS)); // 没有 CLASS 权限
console.log('COUNT=>' + (vnodeType & COUNT)); // 没有 COUNT 权限
```

## [有效的数独](https://leetcode.cn/problems/valid-sudoku/)
### 位运算
1. 解题思路：
    - 基本知识：
      > - 与运算(a&b)：a,b 均为 1 时，返回 1，否则返回 0；
      > - 异或运算(a^b)：a,b 不同时为 0 或 1 时，返回 1，否则返回 0；
    - 本题可以使用一个 9 位二进制数判断数字是否被访问，第 k 位数为 1 代表已加入，为 0 代表未加入；
    - 更新方式(记九位数为 val，传入的数字为 n)：
      > - 判断是否加入：将九位数右移位 n 位，与 1 进行与运算； 结果为 0：未加入，将传入的数字加入九位数；结果为 1：已加入，返回 false；
      > - 将传入的数字加入九位数：将 1 左移位 n 位，与 val 异或即可；
    - 例子：对于数字 1010010000，其第 4,7,9 位为 1，表示当前 4,7,9 已经访问过了；
      > - 新来数字为 3：将 1010010000 右移 3 位得到 1010010，与 1 进行与运算，结果为 0，未访问过；将 1 左移位 3 位得到 1000，异或后得到 1010011000；
      > - 新来数字为 4：将 1010010000 右移 4 位得到 101001，与 1 进行与运算，结果为 1，访问过；返回 false；
2. 复杂度：
    - 时间复杂度：O(1)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```JS
    var isValidSudoku = function (board) {
      // 保存 9行、9列、9块区域的 2进制值
      let row = new Array(9);
      let col = new Array(9);
      let area = new Array(9);
    
      for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
    
          let num = board[i][j];
          if (num == '.') continue;
          num = Number(num);
          let idx = Math.floor(i / 3) * 3 + Math.floor(j / 3);
    
          // 当前行，判断当前元素是否已经存在过
          // 当前列，判断当前元素是否已经存在过
          // 当前区域，判断当前元素是否已经存在过
          if ((((row[i] >> num) & 1) == 1) || (((col[j] >> num) & 1) == 1) || (((area[idx] >> num) & 1) == 1)) {
            return false;
          }
          console.log(Number(row[i]).toString(2));
          console.log(Number(1 << num).toString(2));
    
          // 不断更新 每一行、每一列、每一区域 的标记
          row[i] |= (1 << num);
          col[j] |= (1 << num);
          area[idx] |= (1 << num);
        }
      }
      return true;
    };
    ```

### 一次遍历
1. 解题思路：
    - 可以使用哈希表记录每一行、每一列和每一个小九宫格中，每个数字出现的次数，只需要遍历数独一次，在遍历的过程中更新哈希表中的计数，并判断是否满足有效的数独的条件即可；
    - 利用一个 9*9 二维数组来存储行数据；
    - 利用一个 9*9 二维数组来存储列数据；
    - 利用一个 3*3*9 三维数组来存储区域Ï数据；
2. 复杂度：
    - 时间复杂度：O(1)，数独共有 81 个单元格，只需要对每个单元格遍历一次即可；
    - 空间复杂度：O(1)，由于数独的大小固定，因此哈希表的空间也是固定的；
3. 代码实现：
    ```JS
    var isValidSudoku = function (board) {
      // 9x9 矩阵：存储行数据
      const rows = new Array(9).fill(0).map(() => new Array(9).fill(0));
      // 9x9 矩阵：存储列数据
      const columns = new Array(9).fill(0).map(() => new Array(9).fill(0));
      // 3*3*9 矩阵(每行3个area，每列3个area，每个area有9个元素)：存储区域元素
      const subboxes = new Array(3).fill(0).map(() => new Array(3).fill(0).map(() => new Array(9).fill(0)));
    
      for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
          const num = board[i][j];
    
          if (num !== '.') {
            const index = Number(num) - 1;
    
            // 第 i 行的 num 值 +！
            rows[i][index]++;
            // 第 i 列的 num 值 +！
            columns[j][index]++;
            // 第 x 区域的 num 值 +1
            subboxes[Math.floor(i / 3)][Math.floor(j / 3)][index]++;
    
            // 如果 第 i 行的 num 值的个数大于 1，则说明不满足要求，直接返回 false
            // 如果 第 i 列的 num 值的个数大于 1，则说明不满足要求，直接返回 false
            // 如果 第 x 区域的 num 值 的个数大于 1，则说明不满足要求，直接返回 false
            if (rows[i][index] > 1 ||
              columns[j][index] > 1 ||
              subboxes[Math.floor(i / 3)][Math.floor(j / 3)][index] > 1) {
              return false;
            }
          }
        }
      }
      // 全部迭代结束后，说明满足要求，返回 true
      return true;
    };
    ```


## [2 的幂](https://leetcode.cn/problems/power-of-two/)
1. 解题思路：
    - 若 n = 2^x 且 x 为自然数（即 n 为 2 的幂），则一定满足以下条件：
      - 恒有 n & (n - 1) == 0，这是因为：n 二进制最高位为 1，其余所有位为 0；n - 1二进制最高位为 0，其余所有位为 1；
      - 一定满足 n > 0；
    - 因此，通过 n > 0 且 n & (n - 1) == 0 即可判定是否满足 n = 2^x；
      |2^x|	n|	n - 1	|n & (n - 1)|
      |:---:|:--:|:--------:|:-----------:|
      |2^0 	|0001|	0000|	(0001) & (0000) == 0|
      |2^1	|0010|	0001|	(0010) & (0001) == 0|
      |2^2	|0100|	0011|	(0100) & (0011) == 0|
      |...	|...	|...	|...|
2. 复杂度：
    - 时间复杂度：O(1)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```JS
    var isPowerOfTwo = function (n) {
      return n > 0 && (n & (n - 1)) === 0
    };
    ```


## [只出现一次的数字](https://leetcode.cn/problems/single-number/)
1. 解题思路：
    - 异或运算有以下三个性质：
      - 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0 = a；
      - 任何数和其自身做异或运算，结果是 0，即 a⊕a = 0；
      - 异或运算满足交换律和结合律，即 a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b⊕0 = b；
    - 例如 nums = [1，1，2，3，3]，即1⊕1⊕2⊕3⊕3 = （1⊕1）⊕2⊕（3⊕3）= 0 ⊕ 2 ⊕ 0 = 2；
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是数组长度，只需要对数组遍历一次；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```JS
    var singleNumber = function (nums) {
      let res = 0;

      nums.forEach(num => {
        res ^= num;
      })

      return res;
    };
    ```


## [找不同](https://leetcode.cn/problems/find-the-difference/)
### 位运算
1. 解题思路：
    - 异或运算有以下三个性质：
      - 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0 = a；
      - 任何数和其自身做异或运算，结果是 0，即 a⊕a = 0；
      - 异或运算满足交换律和结合律，即 a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b⊕0 = b；
    - 例如 nums = [1，1，2，3，3]，即1⊕1⊕2⊕3⊕3 = （1⊕1）⊕2⊕（3⊕3）= 0 ⊕ 2 ⊕ 0 = 2；
2. 复杂度：
    - 时间复杂度：O(N)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```JS
    var findTheDifference = function (s, t) {
        let ret = 0;

        for (const ch of s) {
            ret ^= ch.charCodeAt();
        }
        for (const ch of t) {
            ret ^= ch.charCodeAt();
        }

        // 自身和自身异或返回 0，自身和0异或返回自身，最后返回单数的字符
        return String.fromCharCode(ret);
    };
    ```
### 求和
1. 解题思路：
    - 将字符串 s 中每个字符的 ASCII 码的值求和，得到 As；
    - 对字符串 t 同样的方法得到 At；
    - 两者的差值 At - As 即代表了被添加的字符；
2. 复杂度：
    - 时间复杂度：O(N)；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```JS
    var findTheDifference = function (s, t) {
        let as = 0, at = 0;

        for (let i = 0; i < s.length; i++) {
            // 返回字符的 Unicode 编码
            as += s[i].charCodeAt();
        }

        for (let i = 0; i < t.length; i++) {
            // 返回字符的 Unicode 编码
            at += t[i].charCodeAt();
        }

        // 将 Unicode 编码转为一个字符
        return String.fromCharCode(at - as);
    };
    ```


## [根据数字二进制下 1 的数目排序](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/)
1. 解题思路：
    - 此题的考点就是怎么判断出一个数字的二进制有几个 1；
    - 式子 n = n&(n-1)，例如 n=10110 ，则 n-1=1010，相与之后：10100，将 10110变成了10100，即去掉了 n 的最后一个 1；
    - n&(n-1)所表示的含义为：将最后一位 1 变成 0；
2. 图解：
    <img src="根据数字二进制下1的数目排序1.jpg" width="600px" height="auto" class="lazy-load" title="根据数字二进制下1的数目排序"/>
    <img src="根据数字二进制下1的数目排序2.jpg" width="600px" height="auto" class="lazy-load" title="根据数字二进制下1的数目排序"/>
3. 代码实现
    ```JS
    var sortByBits = function (arr) {
        // 计算n的二进制中1的数量
        const bitCount = n => {
            let count = 0;
            while (n) {
                n &= (n - 1); // 清除最低位的1
                count++;
            }
            return count;
        }

        // 如果有差，则按 bits 数排，如果无差，则按原值排
        return arr.sort((a, b) => bitCount(a) - bitCount(b) || a - b);
    };
    ```


## [位 1 的个数](https://leetcode.cn/problems/number-of-1-bits/)
1. 图解
    > n & (n-1) 消除二进制末尾的 1

    <img src="位1的个数1.jpg" width="600px" height="auto" class="lazy-load" title="位1的个数"/>
    <img src="位1的个数2.jpg" width="600px" height="auto" class="lazy-load" title="位1的个数"/>
2. 代码实现
    ```JS
    var hammingWeight = function (n) {
      let res = 0;

      while (n != 0) {
        res += 1;
        n &= n - 1;
      }

      return res;
    };
    ```
    ```TS
    function hammingWeight(n: number): number {
      let res = 0;

      while (n != 0) {
        res += 1;
        n &= n - 1;
      }

      return res;
    };
    ```

## [颠倒二进制位](https://leetcode.cn/problems/reverse-bits/)
### 位运算分治
1. 解题思路：
    <img src="颠倒二进制位（位运算分治）解题思路.jpg" width="600px" height="auto" class="lazy-load" title="颠倒二进制位（位运算分治）解题思路"/>
2. 图解：
    <img src="颠倒二进制位（位运算分治）图解.jpg" width="600px" height="auto" class="lazy-load" title="颠倒二进制位（位运算分治）图解"/>
3. 复杂度：
    - 时间复杂度：O(1)；
    - 空间复杂度：O(1)；
4. 代码实现：
    ```JS
    var reverseBits = function (n) {
      //低16位与高16位交换
      // ffff ffff 右移16位，变成 0000 ffff
      // ffff ffff 左移16位，变成 ffff 0000
      n = (n >>> 16) | (n << 16);

      //每16位中低8位和高8位交换
      n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);

      //每8位中低4位和高4位交换
      n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);

      //每4位中低2位和高2位交换
      n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);

      //每2位中低1位和高1位交换
      n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);

      return n >>> 0;
    };
    ```

### 迭代颠倒
1. 解题思路：
    - res  初始值为 0，每次把  res  左移，把  n  的二进制末尾数字，拼接到结果  res  的末尾；
    - 然后把  n 右移，不断去掉 n 末尾的数字；
2. 图解：无符号右移
    <img src="颠倒二进制位（迭代颠倒）图解.jpg" width="600px" height="auto" class="lazy-load" title="颠倒二进制位（迭代颠倒）图解"/>
3. 复杂度：
    - 时间复杂度：O(1)；
    - 空间复杂度：O(1)；
4. 代码实现：
    ```JS
    var reverseBits = function (n) {
      let res = 0;

      for (let i = 0; i < 32; i++) {
        // res 左移一位，加上 n 的最后一位
        res = (res << 1) | (n & 1);
        // n 每次右移一位
        n >>= 1;
      }

      // x >>> 0本质上就是保证x有意义（为数字类型），且为正整数，且在无意义的情况下缺省值为0
      return res >>> 0;
    };
    ```
    ```TS
    function reverseBits(n: number): number {
      let res = 0;

      for (let i = 0; i < 32; i++) {
        // res 左移一位，加上 n 的最后一位
        res = (res << 1) | (n & 1);
        // n 每次右移一位
        n >>= 1;
      }

      // x >>> 0本质上就是保证x有意义（为数字类型），且为正整数，且在无意义的情况下缺省值为0
      return res >>> 0;
    };
    ```


## [二进制求和](https://leetcode.cn/problems/add-binary/)
1. 解题思路：
    - 两个二进制数字相加，从它们的末位开始遍历：
      - 若对应位数都是 0，则依然是 0，进位为 0；
      - 若一个是 0，一个是 1，则变成 1，进位为 0；
      - 若两个都是 1，则变为 0，进位为 1；
    - 因为二进制只有 0，1，根据以上规律，容易联想到异或运算：
      - 两数相同异或为 0，0 与任意数字异或为数字本身；
      - 所以相加的位数为 a[i] ^ b[j] ^ add；
      - 初始化进位 add = 0，若 a[i]、b[i]、add 中有两个及两个以上数字为1，则 add 为 1；
    - 遍历数组后，已更改全部位数，若此时进位为 1，则需在首部添加 1；
2. 代码实现：
    ```JS
    var addBinary = function (a, b) {
      let add = 0;
      let sum = [];

      for (let i = a.length - 1, j = b.length - 1; i >= 0 || j >= 0; i--, j--) {
        // 位数不够，默认为 0
        let num1 = +a[i] || 0;
        let num2 = +b[j] || 0;

        // 两数相同异或为0，0与任意数字异或为数字本身
        sum.unshift(num1 ^ num2 ^ add);
        add = num1 + num2 + add > 1 ? 1 : 0;
      }

      if (add === 1) sum.unshift(1);

      return sum.join('');
    };
    ```
    ```TS
    function addBinary(a: string, b: string): string {
      let add = 0;
      let sum = [];

      for (let i = a.length - 1, j = b.length - 1; i >= 0 || j >= 0; i--, j--) {
        // 位数不够，默认为 0
        let num1 = +a[i] || 0;
        let num2 = +b[j] || 0;

        // 两数相同异或为0，0与任意数字异或为数字本身
        sum.unshift(num1 ^ num2 ^ add);
        add = num1 + num2 + add > 1 ? 1 : 0;
      }

      if (add === 1) sum.unshift(1);

      return sum.join('');
    };
    ```


## [两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)
### 位运算 + 迭代计算每一位
1. 解题思路：
    - 从低位往高位进行处理，处理过程中使用变量 add 记录进位信息；
    - 由于长度为 32 的二进制，所以循环 32 次，每次取 a、b 第 i 位的值 u1、u2；
    - 记录进位信息：add = u1 + u2 + add > 1 ? 1 : 0;
    - res 记录相加的结果：res |= (u1 ^ u2 ^ add) << i;
2. 复杂度：
    - 时间复杂度：O(C)，C 为常数，固定为 32；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function getSum(a: number, b: number): number {
      let res = 0, add = 0; // 进位

      for (let i = 0; i < 32; i++) {
        // 获取 a、b 二进制位第 i 位的值
        let u1 = (a >> i) & 1, u2 = (b >> i) & 1;

        res |= (u1 ^ u2 ^ add) << i;

        // 判断是否进位
        add = u1 + u2 + add > 1 ? 1 : 0;
      }

      return res;
    };
    ```

### 无进位相加 + 获取进位
1. 解题思路：
    - a ^ b 是无进位的相加；
    - a & b 结果左移一位即可得到进位；
    - 无进位的加法再加上进位就等于两个数相加，让无进位相加的结果与进位不断的异或，直到进位为 0；
2. 复杂度：
    - 时间复杂度：O(C)，C 为常数，固定为 32；
    - 空间复杂度：O(1)；
3. 代码实现：
    ```TS
    function getSum(a: number, b: number): number {
      // 进位为 0，循环终止
      while (b != 0) {
        // 相与为了让进位显现出来
        const carry = (a & b) << 1;

        // 异或这里可看做是无进位相加
        // 让无进位相加的结果与进位不断的异或，直到进位为0
        a = a ^ b;
        b = carry;
      }

      return a;
    };
    ```

### 无进位相加 + 递归
1. 复杂度：
    - 时间复杂度：O(C)，C 为常数，固定为 32；
    - 空间复杂度：O(1)；
2. 代码实现：
    ```TS
    function getSum(a: number, b: number): number {
      // a = (a & b) << 1; 进位
      // b = a ^ b; 无进位相加
      return a == 0 ? b : getSum((a & b) << 1, a ^ b);
    };
    ```


## [数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)
### 解法一
1. 解题思路：参考（2：两数相加）
    <img src="数组形式的整数加法-解题思路.jpg" width="600px" height="auto" class="lazy-load" title="数组形式的整数加法-解题思路"/>
2. 代码实现：
    ```JS
    var addToArrayForm = function (num, k) {
      let sum = [];
      let n = num.length - 1;
      let add = 0;

      while (n >= 0 || k) {
        let u1 = n >= 0 ? num[n--] : 0;
        let u2 = k % 10;
        k = Math.floor(k / 10)

        sum.unshift((add + u1 + u2) % 10);

        add = u1 + u2 + add > 9 ? 1 : 0;
      }

      if (add === 1) sum.unshift(1);
      return sum;
    };
    ```

### 解法二
1. 解题思路：
    - 直接将 k 与 num 的最后一位数字相加，然后计算出 「进位数字」 和 「当前数字」；
    - 此后计算第 i 位的 num[i] 和 ki 的和，再计算出「进位数字」 和 「当前数字」；
    - 直到循环结束，返回 结果数组；
2. 代码实现：
    ```JS
    var addToArrayForm = function (num, k) {
      const res = []
      let i = num.length - 1;

      while (i >= 0 || k > 0) {
        (i >= 0) && (k += num[i--]);

        // 使用push，然后reverse反转，比unshift稍快
        res.push(k % 10);

        k = parseInt(k / 10);
      }

      return res.reverse();
    };
    ```


## [转换成小写字母](https://leetcode.cn/problems/to-lower-case/)
1. 解题思路：
    - 观察小写字母和大写字母的 ASCII 码：
      - 大写字母 A - Z 的 ASCII 码范围为 [65, 90]；
      - 小写字母 a - z 的 ASCII 码范围为 [97, 122]；
    - 小写字母会比大写字母大 32，则直接判断是否当前字母是否在  [65, 90] 区间，在此区间直接加 32 变成小写；
    - [65,96] 对应的二进制表示为 [(01000001)2, (01011010)2]：
      - 65 的二进制为(1000001)2，32 对应的二进制表示为 (100000)2，异或之后变成 (1100001)2 十进制为 97；
      - 因此可以对 ch 的 ASCII 码与 32 做按位或运算，替代与 32 的加法运算；
    <img src="转换成小写字母.jpg" width="600px" height="auto" class="lazy-load" title="转换成小写字母"/>
2. 复杂度：
    - 时间复杂度：O(n)，其中 n 是字符串 s 的长度；
    - 空间复杂度：O(1)，不考虑返回值的空间占用；
3. 代码实现：
    ```JS
    var toLowerCase = function (s) {
      const res = [];

      for (let ch of s) {
        // 返回字符的 Unicode 编码
        if (ch.charCodeAt() >= 65 && ch.charCodeAt() <= 90) {
          // 将 Unicode 编码转为一个字符
          ch = String.fromCharCode(ch.charCodeAt() | 32);
        }
        res.push(ch);
      }

      return res.join('');
    };
    ```


## [数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)
1. 解题思路：
    - 异或运算有以下三个性质：
      >- 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0 = a；
      >- 任何数和其自身做异或运算，结果是 0，即 a⊕a = 0；
      >- 异或运算满足交换律和结合律，即 a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b⊕0 = b；
    - 数组中若「只有一个数字出现一次」，其他数字都出现两次，使用异或，最后的结果就是出现一次的数字；
    - 由于该题「有两个数字出现过一次」，其他数字都出现两次，使用异或，最后的结果是出现一次的两个数字的结果，没办法分出这两个数字，所以将该数组分解成 2 个数组，每个数组都只有一个数字出现一次，其他数字出现两次；
    - 分割两个数组：
      - 首先获取整个数组的异或结果，也就是两个出现一次的数字的异或结果，整个异或结果假如是 1010，说明 1 的位置，两个出现一次的数字的这一位是不同的；
      - 然后获取 1010 中的任意一个 1 的位置分割，这里取最后一个 1；
      - 这样就能分割出两个数组，这两个出现一次的数字会被分在不同的数组里面；
2. 复杂度：
    - 时间复杂度：O(N)，线性遍历 nums 使用 O(N) 时间，遍历 x⊕y 二进制位使用 O(32) = O(1) 时间；
    - 空间复杂度：O(1)，使用常数大小额外空间；
3. 代码实现：
    ```TS
    function singleNumbers(nums: number[]): number[] {
      // 求所有数字异或和
      let sum = 0;
      for (let num of nums) {
        sum ^= num;
      }

      // 找异或和第一个为 1 的位
      let mask = 1;
      while ((sum & mask) == 0) {
        mask <<= 1;
      }

      // 以该位为依据分组异或
      let x = 0;
      let y = 0;
      for (let num of nums) {
        if ((num & mask) == 0) {
          x ^= num;
        } else {
          y ^= num;
        }
      }

      return [x, y];
    };
    ```


## [数组中数字出现的次数II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)
1. 图解：
    <img src="数组中数字出现的次数II.jpg" width="600px" height="auto" class="lazy-load" title="数组中数字出现的次数II"/>
2. 复杂度：
    - 时间复杂度：O(N)，其中 N 位数组 nums 的长度；遍历数组占用 O(N)，每轮中的常数个位运算操作占用 O(1)；
    - 空间复杂度：O(1)，数组 counts 长度恒为 32，占用常数大小的额外空间；
3. 代码实现：
    ```TS
    function singleNumber(nums: number[]): number {
      let res = 0;

      for (let i = 0; i < 32; i++) {
        let count = 0;

        for (let j = 0; j < nums.length; j++) {
          // 先将数右移，并求出最后一位为 1 的个数
          if ((nums[j] >> i & 1) == 1) {
            count++;
          }
        }

        // 找到某一位取余为 1 的数，并左移，为了将这一位循环结束后移至原位
        if (count % 3 != 0) {
          res = res | 1 << i;
        }
      }

      return res;
    };
    ```
---
title: 网络层次模型
categories:
  - Node 全栈开发
  - Node 核心
tags:
  - node
abbrlink: 82d81991
date: 2022-09-18 21:35:30
---

## 网络层次模型
### 对网络的分层有一个清晰的结构认识，不需要掌握每层是如何完成具体工作的：
1. 网络通讯是一个复杂的工程，需要很多基础硬件设备，而这些设备又有很多厂商进行生产，所以为了方便网络的实施、管理和维护，就会有组织推出相应的行业标准规范，目前最常见的就是 OSI 七层模型模型和 TCP/IP 四层模型；
2. 注意：这里的 TCP/IP 并不单指这两个协议，只是在 OSI 七层模型的基础上进行了一些简化，形成了另外一个网络通讯模型；
3. 不论现在使用哪一种模型，它们都是对通讯的过程进行分层，每层当中存在很多协议，例如 HTTP 就属于应用层协议，而 TCP、UDP 就属于传输层协议；

### OSI 七层模型：
1. 应用层：用户（或应用程序）与网络的接口；
    - 可以利用不同的协议完成用户请求的各种服务；
    - 例如，可以利用 HTTP 协议完成网站服务；利用 FTP 协议完成文件传输服务；利用 SSH 协议完成远程登陆服务等；
2. 表示层：数据加密、转换、压缩；
3. 会话层：控制网络连接建立与终止；
4. 传输层：控制数据传输可靠性，这一层是基于端口的协议层，所以数据在封装的时候必须携带目标程序所占用的端口号；
5. 网络层：确定目标网络，通过路由找到目标网络，常见的就是 IP 协议，可以依据 IP 地址确定源和目标的网络；
6. 数据链路层：确定目标主机，在确定了目标网络并进入某个局域网内后通过 Mac 地址确定目标主机，常见的就是 ARP 寻址协议；
7. 物理层：各种物理设备和标准；

### 数据传递，先封装再解封：
1. 数据从 主机A 传递到 主机B，首先要按照分层自上向下的顺序，一层一层的进行数据的封装；
2. 然后到了 主机B 的网卡解调之后，再按照自下向上的顺序进行拆解；
3. 最后在应用程序中拿到 主机A 发送的原始数据；

### 总结：
1. OSI 七层模型的目的是更加清晰规范的完成网络通讯；
2. TCP/IP 四层模型就是在它的基础之上，将前三层（应用层、表示层、会话层）进行合并，统一叫做应用层，再将数据链路层和物理层合并称为网络接入层，最终为应用层–传输层–网络层–网络接入层；
3. TCP/IP 五层模型就是保留数据链路层和物理层，也有称这两层为网络接口层和硬件；
4. 不论是四层还是五层，层的名称是什么只要理解其中原理即可；
5. 这里主要了解的是分层的目的，七层的名称和作用，以及常见的协议名称；

## 数据封装与解封装
### 依据网络通讯的层次模型，以 TCP/IP 五层模型为例，具体的说一下传输数据的封装与解封装的过程
<img src="数据封装.jpg" width="auto" height="300px" class="custom-img" title="数据封装"/>

1. 应用层：首先在应用层产出真正要被传输的数据 data，然后将其传输到传输层；
2. 传输层：传输层最常见的是 TCP、UDP 协议，它们都是基于端口的，端口的作用就是在主机上确定唯一进程，所以数据在这层就会包裹上目标应用端口和应用在当前主机上的源端口，接着数据被传向网络层；
3. 网络层：因为主机处于不同的网络里，所以需要通过 IP 协议确定目标主机所在的网络，因此数据在这层会被包裹上目标主机的 IP 地址和当前主机的源 IP，接着数据被传向链路层；
4. 数据链路层：在数据链路层最主要的就是通过 Mac 地址完成寻址操作，所以数据在这层会被包裹上目标主机的 Mac 地址和当前主机的 Mac 地址，至此一条具有完整信息的数据就封装完成了，接着数据被传向物理层；
5. 物理层：网线不能传递二进制数据，这些二进制数据在经过网卡的调制之后，变成高低电压（图中以二进制形式表示转换后的数据）；
### 有了这些数据后，经过路由器的网络分配和传输介质的运输，最终就到达了目标主机的网卡
<img src="解封装.jpg" width="auto" height="300px" class="custom-img" title="解封装"/>

1. 物理层：首先会做数据的解调，将电压变为二进制，然后再向上传递给链路层；
2. 数据链路层：在链路层就会分析目标的 Mac 地址是否与当前主机的 Mac 地址一致，如果一致则进行拆包，继续向上传递到网络层；
3. 网络层：在这一层会分析目标 IP 是否与当前主机的 IP，如果是，则继续拆包向上传输到传输层；
4. 传输层：这里会检查目标端口是否匹配，如果匹配，则继续拆包向上层传输；
5. 应用层：现在当前网络的目标主机的应用就拿到由另一个网络中的某台主机的某个应用所传递过来的数据；

## TCP 三次握手与四次挥手
### TCP 协议
1. TCP 属于传输层协议；
2. TCP 是面向连接的协议；
3. TCP 一般用于处理实时通信；

### TCP 协议报文结构
1. 常见控制字段：
    - SYN = 1 表示请求建立连接；
    - FIN = 1 表示请求断开连接；
    - ACK = 1 表示数据信息确认；
2. 图解：
    <img src="报文结构.jpg" width="auto" height="300px" class="custom-img" title="报文结构"/>
### 三次握手建立过程
1. 以 C/S 架构为例：
    <img src="架构为例.jpg" width="auto" height="300px" class="custom-img" title="架构为例"/>

    - 首先客户端要向服务端发送一个建立连接的请求（图中以 SYN=1 表示）；
    - 然后服务端接收到请求后就会回送一条消息，表示确认接收到了客户端的请求（图中以 ACK=1 表示）；
    - 任何一次完整的通信都是有来有回的；
    - 这两次请求和回送完成之后就建立了一条由客户端向服务端发送数据的通道；
    - 服务端想要向客户端发送数据，同样需要发送一个请求给客户端，表示它也想建立连接（图中以 SYC=1 表示）；
    - 同样客户端也需要回送一个确认消息给服务端，表示接收到了请求（图中以 ACK=1 表示）；
    - 至此就建立了一条由服务端向客户端发送数据的通道；
2. 不过上图看着像四次握手，而不是三次。其实本来就是四次握手，只不过在实际处理的时候，服务端会在回送客户端 ACK=1 的时候同时还会发送 SYN=1，也就是说它会将这两次握手进行合并，这样就有了最终的三次握手：
    <img src="三次握手.jpg" width="auto" height="300px" class="custom-img" title="三次握手"/>
### 四次挥手过程
<img src="四次挥手.jpg" width="auto" height="300px" class="custom-img" title="四次挥手"/>

1. 首先客户端会向服务端发送一个断开连接的请求；
2. 然后服务端会回送一个消息确认，这时就相当于断开了客户端到服务端的数据通道；
3. 接着服务端会向客户端发送一个断开连接的请求；
4. 客户端收到后也会回送一个确认消息给服务端，断开了服务端到客户端的数据通道；
### 为什么握手可以三次，而挥手必须四次？
1. 至于为什么不将服务端回送客户端的确认消息和服务端请求与客户端断开连接的请求进行合并？
2. 因为一个服务端会服务于多个客户端，不能保证某个客户端将请求发送给服务端之后，服务端就能立即将结果数据全部传输回给当前客户端；
3. 也就是说，有些时候客户端已经把所有的数据都发送给服务端了，但是服务端还没有将客户端想要的数据全部传回，所以在断开连接的时候要分开处理，可以断开客户端向服务端传输的通道，但还不能断开服务端向客户端传输的通道；
4. 因此挥手必须要有四次，而握手就可以合并为三次；
### 总结
1. TCP 处于传输层，基于端口，面向连接；
2. 主机之间要想通信需要先建立双向数据通道；
3. TCP 的握手和挥手本质上都是四次，只不过在断开的时候不能进行合并；